---
layout: post
title: C++程序语言设计基础-笔记PART2
date:   2019-01-02
categories: C++
---

# 第六章
**变量和对象定义在不同的位置其作用域、可见性、生存期都不同**  
函数体内，类体内，函数原型参数表内，所有函数和类之外   
属于整个类的数据成员——静态数据成员  
用于处理静态数据成员的函数——静态成员函数  

**友元**  
对一些类外的函数、其他的类，给予授权，使之可以访问类的私有成员  
通过const关键字，限制对共享数据的修改  

**作用域分类**  
+ 函数原型作用域
+ 局部作用域（块作用域）
+ 类作用域  
+ 文件作用域
+ 命名空间作用域

**函数原型作用域**  
+ 函数原型中的参数 声明
+ 其作用域始于“（” ，结束于“）”   
+ 举例： 
double area(double radius); radius的作用域仅在（）于此，不能用于程序正文其他地方

**局部作用域**  
+ 函数的形参、在块中声明的标识符；
+ 作用域自声明处起，限于块中
+ 举例  

**类作用域**  
+ 类的成员具有类作用域，其范围包括类体。
+ 在类作用域以外访问类的成员；
   + 静态成员：通过类名，或者该类的对象名、对象引用访问。
   + 非静态成员：通过类名，或者该类的对象名，对象引用，对象指针访问
   
 **文件作用域**  
 + 不在前述各个作用域中出现的声明，就具有文件作用域
 + 其作用域开始于声明点，结束于文件尾
 
 
 **可见性**
+ 可见性是从标识符的引用的角度来谈的概念。
+ 可见性表示从内层作用域向外层作用域“看”时能看见什么
+ 如果标识在某处可见，就可以在该处引用词标识符
+ 如果某个标识符在外层声明，且在内层中没有同一标识符的声明，则该标识符在内层可见
+对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符的内存不可见

```
#include<iostream>
using namespace std;
int i ;//全局变量，文件作用域
int main()
{
i = 5;//为全局变量i赋值
{
int i ;
i=7;
cout << "i=" << i << endl;//输出7
}
cout  <<"i="<<i<<endl;//输出5
}

运行结果：
i =7;
i=5;
```

**对象的生存期**  
+ 对象从产生到结束的这段时间，就是它的生存期。
+ 在对象生存期内，对象将保持它的值，知道被更新为止。

**动态生存期**  
+ 开始于程序执行到声明时，结束于命名该标识符的作用域结束处。
+ 块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）

**静态生存期**  
+ 这种生存期与程序的运行期相同
+ 在文件作用域中声明的对象，具有这种生存期。
+ 在函数内部声明静态生存期对象，要冠以关键字static.

```
#include <iostream>
using namespace std;
int i =1;
void other()
{
static int a =2;
static int b;
//a,b为静态局部变量，具有全局寿命，局部可见。
//只第一次进入函数时被初始化。
int c=10;//c为局部变量，具有动态生存期，每次进入函数时都初始化
a+=2;i += 32;c+=5;
cout << "---OTHER---\n:;
cout << "i:" << i <<"a:"<<a<<"b:"<<b<<"c:"<<c<<endl;
b=a;
}

int main(){
static int a;//静态局部变量，具有全局寿命，局部可见
int b = -10;//b,c局部变量，具有动态生存期
int c =0;
cout <<"---MAIN---\n";
cout << "i:" << i <<"a:"<<a<<"b:"<<b<<"c:"<<c<<endl;
c+=8;other();
cout <<"---MAIN---\n";
cout << "i:" << i <<"a:"<<a<<"b:"<<b<<"c:"<<c<<endl;
i+=10;other();
return 0;
}

```   
运行结果：
---MAIN---
i:1 a:0 b:-10 c:0
---OTHER---
i:33 a:4 b:0 c:15
---MAIN---
1:33 a:0 b:-10 c:8
---OTHER---
i:75 a:6 b:4 c:15


**静态数据成员**  
+ 用关键字static声明
+ 为该类的所有对象共享，静态数据成员具有静态生存期
+ 必须在类外定义和初始化，用(::)来知名所属的类

例：

```
#include<iostream>
using namespace std;
 class Point{//Point类定义
 public:
 Point(int x =0,int y =0)::x(x),y(y)//构造函数
 {
 count++;//在构造函数中对count累加，所有对象共同维护同一个count
 }
 Point(Point &p)//复制构造函数
 {
 x=p.x;
 y=p.y;
 count++;
 }
 ~Point(){count--;}
 int getX(){return x;}
 int getY(){return y;}
 void showCount()//输出静态数据成员
 {
 cout <<" Object count=" <<count<<endl;
 }
 private:
 int x,y;
 static int count;
};

int Point::count =0;//静态数据成员定义和初始化，使用类名限定

int main()
{
Point(4,5);
cout << "Point A:" << a.getX()<<","<<a.getY();
a.showCount();

Pointb(a);
cout <<"Point B"<<b.getX()<<","<<b.getY();
b.showCount();
return 0;
}
```

**静态函数成员**
+ 主要用于处理该类的静态数据
+ 静态函数成员如果访问非静态数据成员，要通过对象来访问

```
#include<iostream>
using namespace std;
 class Point{//Point类定义
 public:
 Point(int x =0,int y =0)::x(x),y(y)//构造函数
 {
 count++;//在构造函数中对count累加，所有对象共同维护同一个count
 }
 Point(Point &p)//复制构造函数
 {
 x=p.x;
 y=p.y;
 count++;
 }
 ~Point(){count--;}
 int getX(){return x;}
 int getY(){return y;}
 static void showCount()//输出静态数据成员
 {
 cout <<" Object count=" <<count<<endl;
 }
private:
int x,y;
static int count;
};

int Point::count =0;//静态数据成员定义和初始化，使用类名限定

int main()
{
Point::showCount();
Point(4,5);
cout << "Point A:" << a.getX()<<","<<a.getY();
Point::showCount();

Pointb(a);
cout <<"Point B"<<b.getX()<<","<<b.getY();
Point::showCount();
return 0;
}
```

**类的友元**

+ 友元是C++提供的一种破坏数据封装和数据隐藏的机制
+ 通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息
+ 可以声明友元函数和友元类
+ 为了确保数据完整性，及数据封装的隐藏的原则，建议慎用友元

**友元函数**  
+ 友元函数在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问private和protected成员
+ 作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择
+ 访问对象中的成员必须通过对象名。

```
#include<iostream>
#include<cmath>
class Point
{
public:
Point(int x=0,int y =0):x(x),y(y){}
int getX(){return x;}
int getY(){return y;}
friend float dist(Point &a,Point &b);
private:
int x,y;
};

float dist(Point &a,Point &b)
{
double x =a.x-b.x;
double y=a.y-b.y;
return static_cast<float>(sqrt(x*x+y*y));
}
int main()
{
Point P1(1,1).p2(4,5);
cout<<"The distance is:";
cout<<dist(p1,p2)<<endl;
return 0;
}
```  
运行结果：  
The distance is :5 

**友元类**
+ 若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。
+ 声明语法：将友元类名在另一个类中使用friend修饰说明
+ 类的友元关系是单向的：声明B类是A类的友元不等元A类是B类的友元


**常数型**  
+ 常对象：必须进行初始化，不能被更新。  
const 类名 对象名；
+ 常成员：
用const进行修饰的类成员


























