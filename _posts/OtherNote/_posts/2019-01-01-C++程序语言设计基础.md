---
layout: post
title: C++程序语言设计基础-笔记PART1
date:   2019-01-01
categories: C++
---
# 第一章
**计算机系统**  
+ 计算机系统由硬件、软件组成  
+ 指令系统是硬件和软件的界面 

**计算机语言**  
+ 程序员与计算机沟通的语言  
+ 描述解决问题的方法和相关数据  

**计算机语言的级别**  
+ 二进制代码构成的机器语言  
+ 使用助记符的汇编语言  
+ 使用类似英语单词和语句的高级语言   

![_config.yml]({{ site.baseurl }}/images/C++program decide/image2.jpg)  

**C++支持的程序设计方法**  
+ 面向过程的程序设计方法  
+ 面向对象的程序设计方法  
+ 泛型程序设计方法   

**C++程序的开发过程**   
+ 算法与数据结构设计  
+ 源程序编辑  
+ 编译  
+ 连接  
+ 测试  
+ 调试  

**计算机中的数据都是二进制表示的，逻辑数据、字符数据也用二进制码表示**   

**计算机系统简介**  
+ 计算机解决问题是软件控制的  
+ 软件的程序就是操作步骤  
+ 程序要使用语言来表达  
+ 计算机能识别的是机器语言  
+ 机器语言指令是由0和1编码的  
+ 例如：  
加法指令可能是“0001”  

![_config.yml]({{ site.baseurl }}/images/C++program decide/image1.jpg)  

**计算机指令系统**  
+ 机器硬件能够识别的语言（机器语言）的集合  
+ 它是软件和硬件的主要界面  

**计算机软件**  
软件= 程序+说明文档  

![_config.yml]({{ site.baseurl }}/images/C++program decide/image3.jpg)  

**计算机程序**  
+ 指令的序列  
+ 描述解决问题的方法和数据  

**C++语言**  
+ 是高级语言  
+ 支持面向对象的观点和方法  
   + 将客观事物看做对象  
   + 对象间通过消息传送进行沟通  
   + 支持分类和抽象  
   
**面向过程的程序设计方法：**  
+ 机器语言、汇编语言、高级语言都支持  
+ 最初的目的：用于数学计算  

**大型复杂的软件，难以用面向过程的方式编写**  

**面向对象的程序设计方法：**
+ 由面向对象的高级语言支持
+ 一个系统由对象构成  
+ 对象与对象之间通过消息进行通信  

**对象**  
+ 一般意义上的对象：是现实世界中一个实际存在的事物  
+ 面向对象方法中的对象：是系统中用来描述客观事物的一个实体   

**抽象与分类**  
+ 分类所依据的原则——抽象  
+ 抽象出同一类对象的共同属性和行为，形成类   

**封装**  
+ 隐蔽对象的内部细节   
+ 对外形成一个边界  
+ 只保留有限的对外接口  
+ 使用方便、安全性好  

**继承**   
+ 意义在于软件复用  
+ 改造、扩展已有类形成新的类  

**多态**  
+ 同样的信息作业在不同对象上有可能引起不同的行为  

**高级语言翻译成机器语言程序**  
+ 源程序  
用源语言写的，有待翻译的程序  
+ 目标程序  
源程序通过翻译程序加工以后生成的机器语言程序    
+ 可执行程序  
连接目标程序以及库中的某些文件，生成的一个可执行文件  
例如：  
Windows系统平台上的.EXE文件  

**三种不同类型的翻译程序**  
+ 汇编程序   
将汇编语言源程序翻译成目标程序  
+ 编译程序   
将高级语言源程序翻译成目标程序  
+ 解释程序   
将高级语言源程序翻译成机器指令它是边翻译边执行  
Java程序就是半编程半解释的目的是为了跨平台  

**计算机基本功能**  
+ 算术运算  
+ 逻辑运算  

**计算机中信息**  
+ 控制信息——指挥计算机操作  
+ 数据信息——计算机程序加工的对象  

![_config.yml]({{ site.baseurl }}/images/C++program decide/image5.jpg)  


**信息的存储单位**  
+ 位(bit,b):
数据的最小单位，表示一位二进制信息
+ 字节(byte,B）:
八位二进制数字组成(1byte=8bit)
+ 千字节 1KB=1024B
+ 兆字节 1MB=1024K
+ 吉字节 1GB=1024M

**计算机的数字系统**  
+ 二进制系统  
+ 基本符号：0,1  

**进制之间的转换**  

![_config.yml]({{ site.baseurl }}/images/C++program decide/image4.jpg)  
![_config.yml]({{ site.baseurl }}/images/C++program decide/image6.jpg)  
![_config.yml]({{ site.baseurl }}/images/C++program decide/image7.jpg)  
![_config.yml]({{ site.baseurl }}/images/C++program decide/image8.jpg)  

**补数**   
一个数减去另一个数（加上一个负数）等于第一个数加第二个数的补数  
例：时钟指针    
8+（-2） = 8+10(mod 12)  =6     10是8的在模12上的补数    

**模数**   
n位二进制整数的模数为$$2^n$$  
n位小数的模数为2  

**原码缺点**  
+ 零的表示不唯一   
$$[+0]_{原},[-0]_{原}$$  
+ 进行四则运算时符号位须单独处理且运算规则复杂  

**补码**  
+ 0的表示唯一  
+ 符号位作为数值参加运算  
+ 减去运算可转换为加法运算  
+ 补码运算结果仍为补码  
+ 补码再求补即可得到原码  


**补码的计算规则**  
反码：作为中间码  
+ 负整数：  
原码符号位不变（仍是1）  
其余各位取反（0变1,1变0）  
例如：   
x = -1100110  
$$[x]_{原} = 11100110$$  
$$[x]_{原} = 10011001$$  
+ 正整数：原码就是补码  

负数补码=反码+1  
正数补码= 原码  

如果负数之和得正数或正数之和得负数说明运算结果溢出    

**实数的浮点表示：**  
+ 计算机中通常采用浮点方式表示小数  
+ $$N=M*2^{N}$$  
E：2的幂次，称数N的阶码反映了该浮点数所表示的数据范围  
M：N的尾数，其位数反映了数据的精度  

**字符在计算机中的表示**   

+ 字符在计算机中通过编码表示  
+ ASCII码：  
常用的西文字符编码
7位二进制数表示一个字符
最多可表示$$2^7=128$$个字符
+ 汉子编码：  
中国国家标准《GB 18030-2005 信息技术中文编码字符集》   

```
#include <iostream>
using namespace std
int main()
{
cout<<"Hello!"<<endl;
cout<<"Welcome to C++"<<endl;
return 0;
}
```
 
# 第二章

**C++的产生和发展**  
例：  
```
#include <iostream>
using namespace std;
int main()
{
cout<<"Hello!"<<endl;
cout<<"Welcome to c++!"<<endl;
return 0;
}

运行结果：
Hello!
Welcome to c++!
```

**C++字符集**  
**词法记号**  

**标识符的构成规则：**  
+ 以大写字母，小写字母或下划线(_)开始  
+ 可以由以大写字母，小写字母、下划线(_)或字母0~9组成   
+ 大写字母和小写字母代表不同的标识符   
+ 不能是C++关键字或操作符  

**程序中的数据**  

+ 常量
   + 在源程序中直接写明的数据  
+ 变量
   + 在程序运行过程中允许改变的数据  
   
**整数类型**  
+ 基本的整数类型：int  
+ 按符号分   
符号的（signed）  
无符号（unsigned）  
+ 按照数据范围分  
短整数（short）  
长整数（long）  
长长整数（long long）

**字符类型(char)**  
+ 容纳单个字符的编码
+ 实质上存储的也是整数

**浮点数类型**  
+ 单精度（float）
+ 双精度（double）
+ 扩展精度（long double）

**字符串类型**  
+ 有字符串常量
+ 基本类型中没有字符串变量  
+ 采用字符数组存储字符串（C风格的字符串）  
+ 标准C++类库中的String类（C++风格的字符串）  

**布尔类型(bool )**  
+ 只有两个值：true,false
+ 常用来表示关系比较，相等比较或逻辑运算的结果

**常量**  
+ 在程序运行的整个过程中其值始终不可以改变的量
+ 直接使用符号（文字）表示的值，例如12,3.5,'A'都是常量

**整数常量**  
+ 以文字形式出现的整数  
+ 十进制  
若干个0~9的数字，但数字部分不能以0开头，正数前边的证号可以省略  
+ 八进制  
前导0+若干个0~7的数字  
+ 十六进制  
前导0x+若干个0~9的数字及A~F的字母(大小写均可)  
+ 后缀  
后缀L（或l）表示类型至少是long  
后缀LL（或ll）表示类型是long long  
后缀U（或u）表示unsigned类型  

**浮点数常量**  
+ 以文字形式出现的实数
+ 一般形式：  
例如，12.5，-12.5等  
+ 指数形式  
例如，0.345E+2，-34.4E-3  
整数部分和小数部分可以省略其一
+ 浮点常量默认是double类型，如果后缀F（或f）可以使其成为float型，例如12.3f  

**C风格字符串常量**  
+ 一对双引号括起来的字符序列  
+ 在内存中按串中字符的排列次序顺序存放，每个字符占一个字节   
+ 在末尾添加'\0'作为结尾标记  

**通过添加前缀可以改变字符常量或者字符串常量的类型**  


**变量**  
在程序的运行过程中其值可变的量  

**变量定义**   
+ 数据类型  
变量名1，变量名1，....变量名n

**C++语言中提供了多种初始化方式：**  
例如：  
+ int a=0  
+ int a(0)
+ int a={0}
+ int a{0}  
其中使用大括号的初始化方式称为列表初始化，其列表初始化时不允信息的丢失。例如double值初始化int变量，就会造成数据丢失

**列表初始化**  
+ 使用大括号的初始化方式
+ 不允许信息的丢失

**符号常量**  
+ 常量定义语句的形式为：  
   + const 数据类型说明符 常量名=常量值
   +或数据说明符 const 常量名=常量值
+ 例如：定义一个代表圆周率的符号常量  
   + const float PI =3.1415926  
+ 符号常量在定义时一定要初始化在程序中间不能改变其值  

**主要知识点**  
+ 常量  
在源程序中直接写明的数据，其值在整个程序运行期间不可改变，这样的数据称为常量  
+ 变量  
在运行过程中从计算机的外部设备（如键盘、硬盘）读取的，这些数据的值在程序运行过程中允许改变，这样的数据称为变量    
+ 从键盘输入数据  
iostream 类的对象cin的>>操作，可以从标准输入设备（通常是键盘）读入数据。
+ 数据的存储  
为了存储数据，需要预先为这些数据分配内存空间
变量的定义就是给变量命名的时候分配内存空间   

例：读入并显示整数
```
#include<iostream> 
using namespace std;
int main()
{
int radius;
cout<<"Please enter the radius!\n";
cin>>radius;
cout<<"The radius is:" <<radius<<'\n';
cout<<"PI is:"<<3.14<<'\n';
cout<<"Please enter a different radius!\n";
cin>>radius;
cout<<"Now the radius is changed to:"<<radius<<'\n';
return 0 ;
}
```

例：为常量命名  
```
#include <iostream>
using namespace std
int main()
{
const double pi(3.14159)
int radius;
cout<<"Please enter the radius!\n";
cin>>radius;
cout<<"The radius is:" <<radius<<'\n';
cout<<"PI is:"<<pi<<'\n';
cout<<"Please enter a different radius!\n";
cin>>radius;
cout<<"Now the radius is changed to:"<<radius<<'\n';
}
cout<<"PI is still:"<<<pi<<'\n';
return 0;
```

# 第三章
**I/O流**
+ 在C++中，将数据从一个对象到另一个对象的流动抽象为“流”。流在使用前要被建立，使用后要被删除。
+ 数据的输入和输出是通过I/O流来实现的，cin和cout是预定义的流类对象。cin用来处理标准输入，即键盘输入。cout用来处理标准输出，即屏幕输出。
+ 从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作。  
  
**预定义的插入符和提取符**  
+ “<<”是预定义的插入符，作用在流类对象cout上便可以实现项标准输出设备输出。
   + cout<<表达式<<表达式...
+ 标准输入是将提取符作用在流类对象cin上。
   + cin>>表达式>>表达式...
+ 提取符可以连续写多个，每个后面跟一个表达式，该表达式通常用于存放输入值的变量。例如：
   + int a,b;
   + cin>>a>>b;  
   
**常用的I/O流类库操纵符**  
操纵符名  
dec  数值数据采用十进制表示  
hex  数值数据采用十六进制表示  
oct  数值数据采用八进制表示  
ws   提取空白符  
endl 插入换行符，并刷新流  
ends 插入空字符  
setsprecision(int) 设置浮点数的小数位(包括小数点)  
setw(int)  设置域宽  
例：cout<<setw(5)<<setsprecision(3)<<3.1415;  

**If语句的语法形式**
+ if(表达式)语句  
例：if(x>y)cout<<x;
+ if(表达式)语句1 else语句2  
例：if(x>y)cout<<x;  
    else cout<<y;
+ if(表达式1)语句1  
else if(表达式2)语句2  
else if(表达式3)语句3  
...  
else 语句n  

**嵌套的if结构**
```
#include<iostream>
using namespace std;
int main(){
int x,y;
cout<<"Enter x and y:";
cin>>x>>y;
if(x!=y){
if(x>y)
cout<<"x>y"<<endl;
else
cout<<"x<y"<<endl;
}else
cout<<"x=y"<<endl;
return 0;
}
运行结果1：
Enter x and y:5 8
x<y
运行结果2：
Enter x and y:8 8
x=y
运行结果3：
Enter x and y:12 8
x>y
```
**switch语句的语法**
switch(表达式)  
{  
case 常量表达式1：语句1  
case 常量表达式2：语句2  
       .  
       .  
case 常量表达式n：语句n  
default:          语句n+1  
}  

+ 执行顺序：
   + 以case中的常量表达式值为入口标号，由此开始顺序执行。因此，每个case分支最后应该加break语句。意思是如果case 常量表达式n是True，则后面case的语句(n+1..)都会执行
+ 注意：
   + case分支可包含多个语句，且不用{}。
   + 表达式，判断值都是int型或char型
   + 如果若干支执行内容相同可共用一组语句。  
   
```
#include <iostream>
using namespace std;
int main(){
int day;
cin>>day;
switch(day){
case 0:cout<<"Sunday"<<endl;break;
case 1:cout<<"Monday"<<endl;break;
case 2:cout<<"Tuesday"<<endl;break;
case 3:cout<<"Wednesday"<<endl;break;
case 4:cout<<"Thursday"<<endl;break;
case 5:cout<<"Friday"<<endl;break;
case 6:cout<<"Saturday"<<endl;break;
default:
cout<<"Day out of range Sunday..Saturday"<<endl;break;
}
return 0;
}

```
**while语句的语法形式**  
while(表达式)语句  
+ 执行顺序  
先判断表达式的值，若为true时，执行语句。
+ 注意  
while(表达式)语句，语句可以是复合语句，其中必须含有改变条件表达式值的语句。
```
#include<iostream>
using namespace std;
int main(){
int i =1,sum = 0;
while(i<=10){
sum+=i;
i++;}
cout<<"sum="<<sum<<endl;
return 0}
```  
**do-while语句的语法形式**  
do 语句  
while(表达式)  
+ 执行顺序  
先执行循环体语句，后判断条件。表达式为True时，继续执行循环体。
```
#include<iostream>
using namespace std;
int main(){
int n,right_digit,newnum=0;
cout<<"Enter the number:";
cin>>n;
cout<<"The number in reverse order is";
do{
right_digit=n%10;
cout<<right_digit;
n/=10;
}while(n!=0);
cout<<endl;
return 0;}
```

**for语句的语法形式**  
for(初始语句；表达式1；表达式2）语句  
循环前先求解初始语句，表达式1为True时执行循环体，每次执行完循环体后求解表达式2  
+ for语句另一种形式：范围for语句  
for(声明：表达式）  
语句  

**循环结构与选择结构的嵌套**  
例：输入一系列整数，统计出正整数个数i和负整数个数j,读入0则结束。  
+ 分析：
   + 需要读入一系列整数，但是整数个数不定，要在每次读入之后进行判断，因此使用while循环最为合适。循环控制条件应该是n!=0。  
   + 由于要判断数的正负并分别进行统计，所以需要在循环内部嵌入选择结构。  
```
#include<iostream>
using namespace std;
int main(){
int i =0,j=0,n;
cout<<"Enter some integers please(enter 0 to quit)"<<endl;
cin>>n;
while(n!=0){
if(n>0)i+=1;
if(n<0)j+=1
cin>>n;}
cout<<"Count of positive integers:"<<j<<endl;
cout<<"Count of negative integers:"<<i<<endl;
return 0;}
```

**其他控制语句**
+ break语句
使程序从循环体和switch语句内跳出，继续执行逻辑上的下一条语句。
不宜用在别处。
+ continue语句
结束本次循环，接着判断是否执行下一次循环。
+ goto语句
使程序的执行流程跳转到语句标号所指定的语句。不提倡使用  

**类型别名：为已有类型另外命名**  
+ typedef 已有类型名 新类型名表  
   + 例：  
   typedef double Area, Volume;  
   typedef int Natural;  
   Natural i1,i2;  
   Area a;  
   Volume V;  
+ using 新类型名=已有类型名  
   + 例：  
   using Area = double  
   using Volume = double  
   
**枚举类型**  
+ 定义方式：  
将全部可取值一一列举出来  
+ 语法形式：  
enum 枚举类型名{变量值列表}  
enum Weekday{SUN,MON,TUE,WED,THU,FRI,SAT}  
默认情况下  
SUN=0,MON=1,TUE=1,...,SAT=6  
+ C++包含两种枚举类型：  
   + 不限定作用域枚举类型：  
   enum 枚举类型名 {变量值列表}  
   + 限定作用域的enum类   
   
**不限定作用域枚举类型说明：**  
+ 枚举元素是常量，不能对它们赋值。   
   + 例如有如下定义  
   enum Weekday{SUN,MON,TUE,WED,THU,FRI,SAT}  不能写赋值表达式：SUN=0  
+ 枚举类型具有默认值，它们依次为0,1,2....  
+ 也可以在声明时另行制定枚举元素的值   
如：enum Weekday{SUN=7,MON=1,TUE,WED,THU,FRI,SAT} MON后面元素值依次为2,3,4...  
+ 枚举值可以进行关系运算  
+ 整数值不能直接赋给枚举变量  
如需要将整数赋值给枚举变量，应进行强制类型转换   
+ 枚举值可以赋给整型变量  

+ 例：  
设某次体育比赛结果有四种可能：  
胜（WIN）、负（LOSE）、平局（TIE）、比赛取消（CANCEL）  
编写程序顺序输出这四种情况  
   + 分析：  
比赛结果只有四种可能，可以声明一个枚举类型    
```
#include<iostream>
using namespace std;
enum GameResult {WIN,LOSE,TIE,CANCEL};
int main(){
GameResult result;
enum GameResult omit = CANCEL;
for(int count=WIN;count<=CANCEL;count++){
result = GameResult(count);
if(result == omit)
cout<<"The game was cancelled"<<endl;
else{
cout<<"The game was played";
if(result == WIN)cout<<"and we won!";
if(result == LOSE)cout<<"and we lost!";}}
return 0;
}
```
   
**auto类型与decltype**   
+ auto:编译器通过初始值自动推断变量的类型  
例如：auto val = val1+val2  
如果val1+val2是int类型，则val是int类型  
如果val1+val2是double类型，则val是double类型    
+ decltype:定义一个变量与某一表达式的类型相同，但并不用该表达式初始化变量  
例如：decltype(i)j=2  
表示j以2作为初始值，类型与i一致  


# 第四章  

**函数——程序的功能模块**  

函数：定义好的可重用的功能模块  
定义函数：将一个模块的算法用C++描述出来  
函数名：功能模块的名字  
函数的参数：计算所需要的数据和条件  
函数的返回值：需要返回的计算结果  

**函数定义的语法形式**  

类型标识符 函数名（形式参数表）  
{  
语句序列
}  
+ 形式参数表：<type1>name1,<type2>name2,...<typen>namen 是被初始化的内部变量，寿命和可见性仅限于函数内部  
+ 语句序列最后一句是return语句  
+ 类型标识符表示返回类型，由return语句给出返回值，若无返回值，写void，不必谢return语句  
 
**函数调用**  

函数名（实参列表）
+ 实参列表初始化形式参数表  

**嵌套调用** 

递归调用：函数直接或间接调用自身  
例：编写一个求x的n次方的函数  
```
#include <iostream>  
using namespace  std  

//计算x的n次方
double power(double x,int n){
double val = 1.0;
while(n--)
val*=x
return val
}

int main(){
double pow;
pow = power(5,2)
cout<<"5 to the power 2 is"<<pow<<endl;
return 0
}
```
例：数制转换 输入一个8位二进制数，将其转换为十进制数输出  
```
#include <iostream>  
using namespace std;
double power(double x ,int n);

int main(){
int value =0;
cout<<"Enter an 8 bit binary number";
for(int i =7;i>=0;i--){
char ch ;
cin>>ch;
if(ch=='1')
value += static_cast<int>(power(2,i));//类型转换
}
cout<<"Decimal value is"<<value<<endl;
return 0;
}

double power (double x ,int n){
double val =1.0;
while(n--)
val *=x;
return val;}

运行结果： 
Enter an 8 bit binary number 01101001
Decimal value is 105
```
例  
```
#include <iostream>  
using namespace std;

double arctan(double x){
double sqr =x*x;
double e=x;
double r=0;
int i =1;
while(e/i>le-15){
double f=e/i;
r = (i%4==1)? r+f:r-f;
e = e*sqr;
i += 2;
}
return r;
}

int main(){
double a = 16.0*arctan(1/5.0);
double b = 4.0*arctan(1/239.0);
//注意：因为整数相除结果取整，如果参数写1/5,1/239，结果就都是0

cout<<"PI ="<<a-b<<endl;
return 0;
}
```
例：寻找并输出11~999之间的数m它满足$$m,m^2,m^3$$均为回文数  
回文：各位数字左右对称的整数  
例如：11满足上述条件  
$$11^2=121,11^3=1331$$  
```
#include<iostream>
using namespace std;
//判断是否为回文
bool symm(unsigned n){
unsigned i = n;
unsigned m = 0;
while(i>0){
m = m*10+i%10;
i/=10;
}
return m==n;
}

int main(){
for(unsigned m =11; m<1000;m++)
if(symm(m)&&symm(m*m)&&symm(m*m*m)){
cout<<"m-"<<m;
cout<<"m*m"<<m*m;
cout<<"m*m*m="<<m*m*m<<endl;
}
return 0;
}
```
例  

**在函数被调用时才分配形参的存储单元**  

实参可以是常量、变量或表达式  
实参类型必须与形参相符  
值传递是传递参数值，即单向传递  
引用传递可以实现双向传递  
常引用作参数可以保障实参数据的安全  

引用类型  
+ 引用(&)是标识符的别名  
+ 定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象  
+ 例如：  
int i,j;  
int &ri =i;//定义int引用ri，并初始化为变量i的引用   
j=10;  
ri=j;//相当于i=j  

+ 一旦一个引用被初始化后，就不能改为指向其他对象  
+ 引用可以作为形参  

例：输入两个整数交换后输出(值传递)
```
#include<iostream>
using namespace std;
void swap(int a,int b){
int t=a;
a=b;
b=t;
}
int main(){
int x =5,y=10;
cout<<"x="<<x<<"y="<<y<<endl;
swap(x,y);
cout<<"x="<<x<<"y="<<y<<endl;
return 0;
}
运行结果
x=5,y=10
x=5,y=10
```
例：输入两个整数并交换(引用传递)
```
#include<iostream>
using namespace std;
void swap(int& a,int& b){
int t=a;
a=b;
b=t;
}
int main(){
int x =5,y=10;
cout<<"x="<<x<<"y="<<y<<endl;
swap(x,y);
cout<<"x="<<x<<"y="<<y<<endl;
return 0;
}
运行结果
x=5,y=10
x=10,y=5
```

**含有可变参数的函数**  

+ C++标准中提供了两种主要的方法  
   + 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型  
   + 如果实参的类型不同，我们可以编写可变参数的模板  
+ initializer_list
   + initializer_list是一种标准库类型，用于表示某种特定类型的值的数组该类型定义在同名的头文件中   


# 第五章

**对象：现实中对象的模拟，具有属性和行为**    
**类：同一类对象的共同属性和行为**   

定义对象时，通过构造函数初始化  
删除对象时，通过析构函数释放资源  
对象是类的实例  
定义类的对象，才可以通过对象使用类中定义的功能  

**类的组合**(略)  

**抽象**

+ 对同一类对象的共同属性和行为进行概括，形参类。
   + 首先注意问题的本质及描述，其次是实现过程或细节
   + 数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）
   + 代码抽象：描述某类对象的共有的行为特征或具有的功能。
   + 抽象的实现：类。  
   
**抽象实例——钟表** 

+ 数据抽象：
int hour,int minute, int second
+ 代码抽象：
setTime(), showTime()
```
class Clock{
public:
void setTime(int newH,int newM, int newS);
void showTime();
private:
int hour, minute,second;};
```

**封装**    

将抽象出的数据、代码封装在一起形成类。  
+ 目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。  
+ 实现封装：类声明中的{}  

**继承**  

在已有的基础上，进行扩展形成新的类。  

**多态**  

+ 多态：同一名称，不同的功能实现方式。  
+ 目的：达到行为标识统一，减少程序中标识符的个数  


**设计类就是设计类型**  

+ 此类型的“合法值”是什么？  
+ 此类型应该有什么样的函数和操作符？ 
+ 新类型的对象该如何被创建和销毁？   
+ 如何进行对象的初始化和赋值？   
+ 对象作为函数的参数如何以值传递？  
+ 谁能使用此类型的对象成员？  

**类定义的语法形式**  

class 类名称{   
public:   
公有成员（对外接口）  
private:  
私有成员  
protected：   
保护型成员  
}  

**为数据成员设置类内初始值用于初始化数据成员**    

```
class Clock{
public:
void setTime(int newH,int newM, int newS);
void showTime();
private:
int hour=0, minute=0,second=0;};//类内初始值
```
**类成员的访问控制**  

+ 公有类型成员  
在关键字public后面声明，它们是类与外部的接口，在任何外部函数都可以访问公有类型数据和函数。  
+ 私有类型成员   
在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。   
如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。  
+ 保护类型成员  
与private类似，其差别表现在继承与派生时对派生类的影响不同。  

**对象定义的语法**    

类名 对象名；  
例：   
Clock myClock;  

**类中成员之间直接使用成员名互相访问**  
**从类外访问成员使用“对象名.成员名”方式访问 public成员**  

**类的成员函数**   
 
+ 在类中声明函数原型   
+ 可以在类外给出函数体实现，并在函数名前使用类名前使用类名加以限定；  
+ 也可以直接在类中给出函数体，形成内联成员函数；  
+ 允许声明重载函数和带默认参数值的函数；

**内联成员函数**   

+ 为了提高运行时的效率，对于较简单的函数可以声明为内联形式。  
+ 内联函数体不要有复杂结构（如循环语句和switch语句）。  
+ 在类声明内联成员函数的方式：  
将函数体放在类的声明中  
使用inline关键字  
+ 有些简单的函数，会自动转为内联函数，声明内联只是建议，不一定会有效?

```
#include<iostream>
using namespace std;
//类的定义
class Clock{
public:
void setTime(int newH,int newM, int newS);
void showTime();
private:
int hour, minute,second;
}
//成员函数的实现
void Clock::setTime(int newH,int newM, int newS){  
hour = newH;
minute = newM;
second = newS;
}
void Clock::showTime()
{
cout<<hour<<":"<<minute<<":"<<second;
}
//对象的使用
int main(){
Clock myClock;
myClock.setTime(8,30,30);
myClock.showTime();
return 0;
}
```
**构造函数**  

+ 类中的特殊函数
+ 用于描述初始化算法

**构造函数的作用**  

+ 在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。
+ 例如：  
希望在构造一个Clock类对象时，   
将初试时间设为0:0:0，  
就可以通过构造函数来设置。  

**构造函数的形式**  
+ 函数名与类名相同
+ 不能定义返回值类型，也不能有return语句
+ 可以有形式参数，也可以没有形式参数 
+ 可以是内联函数
+ 可以重载
+ 可以带默认参数值
**构造函数的调用时机**  
+ 在对象创建时被自动调用
+ 例如：
Clock myClock(0,0,0)

**默认构造函数**  
+ 调用时可以不需要实参的构造函数
参数表为空的构造函数
全部参数都有默认值的构造函数
+ 下面两个都是默认构造函数，如在类中同时出现，将产生编译错误
Clock();  
Clock(int newH=0,int newM=0, int newS=0);

**隐含生成的构造函数**
+ 如果程序中未定义构造函数，编译器将自动生成一个默认构造函数
   + 参数列表空，不为数据成员设置初始值
   + 如果类内定义了成员的初始值，则使用内类定义的初始值
   + 如果没有定义类内初始值，则以默认方式初始化
   + 基本类型数据默认初始化值是不确定的
   + 非基本类型，则取决于数据的类
 
 **"=default"**  
 + 如果程序中已定义构造函数，默认情况下编译器就不再隐含生成默认构造函数。如果此时依然希望编译器隐含生成默认构造函数，可以使用“=default”。   
 例：  
 ```
 class Clock{
 public:  
 Clock()=default;  
 Clock(int newH, int newM,int newS);
 private:
 int hour,minute,second;};
 ``` 
 
**构造函数举例**  
```
//类定义
class Clock{
public:
Clock(int newH,int newM,int newS);//构造函数
void setTime(int newH,int newM, int newS);
void showTime();
private:
int hour,minute,second;
};
//构造函数的实现：
Clock::Clock(int newH,int newM,int newS):
hour(newH),minute(newM),second(newS){
}
//其他函数实现...
 int main(){
 Clock c(0,0,0);
 c.showTime();
 return 0;}
```

```
class Clock{
public:
Clock(int newH,int newM,int newS);//构造函数
Clock();//默认构造函数
void setTime(int newH,int newM, int newS);
void showTime();
private:
int hour,minute,second;
};

Clock::Clock():hour(0),minute(0),second(0){}//默认构造函数实现
//其他函数实现


int main(){
Clock c1(8,10,0);//调用有参数的构造函数
Clock c2;//调用无参数的构造函数
.......
}
```

**委托构造函数**    

+ 委托构造函数使用类的其构造函数执行初始化过程    
+ 例如：    
Clock(int newH,int newM,int newS):     
hour(newH),minute(newM),second(newS)    
{};    
Clock():Clock(0,0,0){}    


**复制构造函数定义**   

+ 复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。    
class 类名{    
public:    
类名(形参)；//构造函数    
类名(const 类名&对象名)；//复制构造函数 const 修饰引用 引用对象不能被修改    
};    
类名::类(const 类名 &对象名)    
{函数体}    
 
 **复制构造函数被调用的三种情况**   
 
 + 定义一个对象时，以本类另一个对象作为初始值，发生复制构造；  
 + 如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；  
 + 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造；  
    + 这种情况可以通过移动构造避免不必要的复制。  
    
 **隐含的复制构造函数**    
 
 + 如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。  
 + 这个构造函数执行功能时：用初始值对象的每个数据成员，初始化将要加你的对象的对应数据成员。  
 
 
 **“=delete”**   
 
 如果不希望对象被复制构造    
 + C++98:将复制构造函数声明为private，并且不提供函数的实现    
 + C++11:用"=delete"指示编译器不生成默认复制构造函数    
 
 例：  
 ```
 clss Point{//类的定义
 public:
 Point(int xx=0, int yy=0){
 x = xx;
 y = yy; }
 Point(const Point& p )=delete;//指示编译器不生成默认复制构造函数
 private:
 int x,y;//私有数据

 }
 ```  
 
 **例子**  
 
 ```
 clss Point{//类的定义
 public:
 Point(int xx=0, int yy=0){
 x = xx;
 y = yy; }
 Point(const Point& p );
 private:
 int x,y;//私有数据

 }
 
 //成员函数的实现
 Point::Point(const Point &p){
 x = p.x;
 y = p.y;
 cout<<"Calling the copy constructor"<<endl;
 }
 
 void fun1(Point p){
 cout<<p.getX()<<endl;
 }
 
 Point fun2(){
 Point a;
 return a
 }
 
 int main(){
 Point a;//第一个对象A
 Point b(a);//情况一，用A初始化B。第一次调用拷贝构造函数
 cout<<b.getX()<<endl;
 fun1(b);//情况二，对象作为fun1的实参。第二次调用拷贝构造函数
 b = fun2();//情况三，函数的返回值是类对象，函数返回时调用拷贝构造函数
 cout<<b.getX()<<endl;
 return 0;
 }
 ```
 
**析构函数完成对象删除前的一些清理工作**   
**如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空。**  
+ 析构函数的原型  ~类名();  
+ 析构函数没有参数，没有返回类型    
  
例：  
```
#include<iostream>
using namespace std;
clss Point{//类的定义
 public:
 Point(int xx, int yy)；
 ~Point();
 //其他函数声名....
 private:
 int x,y;//私有数据
 }
 
 Point::Point(int xx,int yy)
 {
 x=xx;
 y=yy;
 }
 Point::~Point()
 {}
```

**组合的概念**  

+ 类中的成员是另一个类的对象  
+ 可以在已有抽象的基础上实现更复杂的抽象  

**类组合的构造函数设计**    

+ 原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化。    
+ 声明形式：   
类名::类名(对象成员所需的形参，本类成员形参)：   
  对象1(参数)，对象2(参数),....{    
  //函数体其他语句  
  }  
  

**构造组合类对象时的初始化次序**   

+ 首先对构造函数初始化列表中列出成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体重定义的次序。   
   + 成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造。    
   + 初始化列表中未出现的成员对象，调用默认构造函数（即无形参的）初始化    
+ 处理完初始化列表之后，再执行构造函数的函数体。  

例：  
```
//拷贝构造函数的实现
Point::Point(Point &p)
{
x=p.x;
y=p.y;
cout<<"Calling the copy constructor of Point"<<endl;
}

class Line{
public:
Line(Point xp1,Point xp2);
Line(Line &l);
double getLen()
{
return len;}
private:
Point p1,p2;
double len;
}
//组合类的构造函数
Line::Line(Point xp1 ,Point xp2 ):p1(xp1),p2(xp2){
cout<<"Calling constructor of Line"<<endl;
double x = static_cast<double>(p1.getX()-p2.getX());
double y = static_cast<double>(p1.getY()-p2.getY());
len = sqrt(x*x+y*y);
}

组合类的拷贝函数
Line::Line(Line &l):p1(l.p1),p2(l.p2)
{
cout<<"Calling the copy of constructor of Line"<<endl;
len = l.len;
}

//主函数
int main(){
Point myp1(1,1),myp2(4,5);//建立Point类的对象
Line line(myp1,myp2);
Line line2(line);
cout<<"The length of the line is:";
cout<<line.getLen()<<endl;
cout<<"The length of the line2 is:";
cout<<line2.getLen()<<endl;
}
```

+ 类应该先声明，后使用  
+ 如果需要在某个类的声明之前，引用该类，则应进行行前向引用声明。  
+ 前向引用声明只为程序引入一个标识符，但具体声明在其他地方。  

例：  
```
class B;
class A{
public :
void f(B,b);
};
class B{
public:
void g(A a);
};
```

**前向引用声明注意事项**   

+ 在提供一个完整的类声明之前，不能声明该类的对象，也不能再内联成员函数中使用该类对象。  
+ 当使用前向声明时，只能使用被声明的符号，而不能涉及类的任何细节。  

例：  
```
class Fred;//前向引用声明
class Barney{
Fred x;//错类 类的Fred的声明尚不完善,创建对象会使用到对象大小，涉及类的细节
};
class Fred{
Barney y;
};

```

**结构体**    
 
+ 结构体是一种特殊形态的类  
+ 与类的唯一区别：  
类的缺省访问权限是private,结构体的缺省访问权限是public。  
+ 什么时候使用结构体而不用类  
   + 定义主要用来保存数据，而没有什么操作的类型  
   + 人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便。   
   
**结构体定义**    

struct 结构体名称{  
公有成员  
protected:  
保护型成员  
private:  
私有成员  
}；  

**结构体中可以有数据成员和函数成员**  
**结构体的初始化**  

如果：  
+ 一个结构体的全部数据成员都是公共成员；   
+ 没有用户定义的构造函数；  
+ 没有基类和虚函数；  
这个结构体的变量可以用下面的语法形式初始化：   
类型名 变量名 ={成员数据1初值,成员数据2初值,......};    

例：  
```
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;

struct Student{
int num;
string name;
char sex;
int age;
};

int main(){
Student stu={97001,"Lin Lin",'F',19};
cout<<"Num:"<<stu.num<<endl;
cout<<"Name:"<<stu.name<<endl;
cout<<"Sex:"<<stu.sex<<endl;
cout<<"Age:"<<stu.age<<endl;
return 0;
}

运行结果：
Num:97001
Name:Lin Lin
Sex:F
Age:19
```

   
**联合体定义形式**   

union 联合体名称{  
公有成员  
protected:  
保护型成员  
private:  
私有成员  
};  

特点：  
+ 成员共用一组内存单位  
+ 任何两个成员不会同时有效  

**联合体的内存分配**    

![_config.yml]({{ site.baseurl }}/images/C++program decide/image19.jpg)   

**无名联合体**    

例：   
union{    
int i;    
float j;    
}    
在程序中可以这样使用：    
i = 10;    
f=2.2;//i的值会被冲掉，因为他们是共用存储空间    

```
#include<string>
#include<iostream>
using namespace std;
class ExamInfo{
private:
string name;
enum{GRADE,PASS,PERCENTAGE} mode;
union{
char grade;
bool pass;
int percent;};
};

public:
ExamInfo(string name, char grade):name(name),mode(GRADE),grade(grade){}
ExamInfo(string name, bool pass):name(name),mode(PASS),pass(pass){}
ExamInfo(string name, int percent):name(name),mode(PERCENTAGE),percent(percent){}

void ExamInfo::show{
cout<<name<<":"";
switch(mode){
case GRADE:cout<<grade; break;
case PASS: cout<<(pass? "PASS":"FAIL");break;
case PERCENTAGE :cout<<percent;break;
}
cout<<endl;
}

int main()
{
ExamInfo course1("English",'B');
ExamInfo course1("Calculus",'true');
ExamInfo course1("C++ Programming",'85');

course1.show();
course2.show();
course3.show();
return 0;
}

运行结果：
English:B
Calculus:PASS
c++ Programming:85
```


**枚举类定义**    

+ 语法形式    
enum class 枚举类型名：底层类型{枚举值列表}；   
+ 例：  
enum calss Type{General,Light,Medium,Heavy};  
enum class Type:char {General,Light,Medium,Heavy};  
enum class Category {General=1,Pistol,MachineGun,Cannon};  


**枚举类的优势**  

+ 强作用域，其作用域限制在枚举类中。  
例：使用Type的枚举值General：  
Type::General    
+ 转换限制，枚举类对象不可以与整型隐式地互相转换。    
+ 可以指定底层类型。    
例：  
enum class Type:char{General,Light,Medium,Heavy};    

例：  
```
#include<iostream>
using namespace std;
enum class Side{Right,Left};
enum class Thing{Wrong,Right};
int main()
{
Side s = Side::Right;
Thing w = Thing::Wrong;
cout<<(s==w)<<endl;
return 0;
}

```

**UML有三个基本的部分**    
事物（Things）  
关系（Relationships）  
图（Diagrams） 


![_config.yml]({{ site.baseurl }}/images/C++program decide/image9.jpg)    
![_config.yml]({{ site.baseurl }}/images/C++program decide/image10.jpg)    
![_config.yml]({{ site.baseurl }}/images/C++program decide/image11.jpg)   
![_config.yml]({{ site.baseurl }}/images/C++program decide/image12.jpg)    
![_config.yml]({{ site.baseurl }}/images/C++program decide/image13.jpg)    
![_config.yml]({{ site.baseurl }}/images/C++program decide/image14.jpg)    
![_config.yml]({{ site.baseurl }}/images/C++program decide/image15.jpg)    
![_config.yml]({{ site.baseurl }}/images/C++program decide/image16.jpg)       
![_config.yml]({{ site.baseurl }}/images/C++program decide/image18.jpg)   
