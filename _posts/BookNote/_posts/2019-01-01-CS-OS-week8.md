---
layout: post
title: week8 存储模型(2)
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

![_config.yml]({{ site.baseurl }}/images/88OS/image326.png)  

# 1、虚拟存储技术(VIRTUAL MEMORY)  

虚拟内存、虚拟地址空间、虚拟地址  

![_config.yml]({{ site.baseurl }}/images/88OS/image327.png)

![_config.yml]({{ site.baseurl }}/images/88OS/image328.png)

虚存是建立在存储体系之上的，它的一部分内容在内存，一部分内容在磁盘，整体构成了这个进程的虚拟地址空间，就是把内存与磁盘有机的结合起来使用，从而得到了 一个容量很大的内存

虚存的大小是受到计算机系统的寻址机制和磁盘空间当中可用空间这两方面的限制，比如一个 32 位的计算机，那么虚拟地址空间最大可达到 2 的 32 次方，也就是 4G 。一个 64 位的计算机 那么虚拟地址空间最大可以达到 2 的 64 次方 

![_config.yml]({{ site.baseurl }}/images/88OS/image329.png)

存储保护主要有几方面的考虑：

+ 要确保每个进程有自己独立的地址空间，通过在创建进程的时候给每个进程分配它独立的地址空间，使得进程之间不会互相干扰 

+ 当进程要访问地址空间的时候，要确保它访问的地址范围是合法的地址范围，也就是说，要防止进程在访问地址空间的过程中出现了地址越界的现象，访问了不该访问的地方

例子，假设把一个进程加载到内存，那么在内存里就有一段空间是属于这个进程的，有一个起始的地址，有一个结束的地址，当 CPU 在执行过程中取指令的时候或者取数据的时候，得到了一个地址，我们要确保这个地址是进程可以访问的范围之内，因此设置了两个寄存器，一个是基地址寄存器，一个是界限寄存器，这两个寄存器都是操作系统通过一些特定的特权指令加载到这个寄存器里头去的，就是把这个进程的起始地址和结束的地址，通过特定的指令加载到这个寄存器里，CPU 取到了指令之后就会去和这些寄存器的内容进行相应的比较，如果这个地址小于基地址那么就越界了，或者是大于等于基地址加上一个界限寄存器的值，那么它也出界了，总之，通过这样一个硬件的判定，能够确保进程访问的地址空间是一个合法的地址空间

+ 是要确保进程的对存储器的操作是合法的，这是权限的问题，也就是说你不能够越权访问，如果这个地址空间是只读的，那你做了写操作，实际上就违反了权限  

![_config.yml]({{ site.baseurl }}/images/88OS/image330.png)  

并不是把全部页面装入内存

虚拟页式存储管理方案通常有两种形式，一种叫做请求调页 Demand paging 就是说我需要了这个页面，这个页面还没在内存，这个时候操作系统把它调入内存。 还有一种方式称为预先调页 叫 prepaging，可以经过一些预测，哪些页面即将会被用到，我可以提前把它调入内存

通常虚拟页式存储管理方案是将两种方式呢结合起来，主要的是采用的是请求调页，在请求调页的过程中完成一些预测的工作

虚拟页式存储管理方案或是虚拟存储技术，其实在操作系统当中是一种资源转换技术，它是用CPU和磁盘来换取内存资源。

![_config.yml]({{ site.baseurl }}/images/88OS/image331.png) 

# 2、页表及页表项的设计  

多级页表、X86的页表项示例

在这个示意当中并不是虚拟地址空间的所有的虚页面都加载到内存了，只是部分内容加载到内存，当这个进程运行的过程中如果要访问到了一些页面，那么就要通过页表的设置得到这样的信息，哪些页面已经加载到内存了，哪些页面没有加载到内存 

![_config.yml]({{ site.baseurl }}/images/88OS/image332.png)  

页表项当中应该保存这样一些信息：页框号、 有效位、 访问位、 修改位和保护位。

页框号是最重要的一个信息。 虚页号对应到了哪一个具体的页框，通过页框号来给出这个具体的物理页面。 

有效位是确保这个页表项所对应的虚页面它是在内存还是在磁盘上，通常有效位如果是 0，就表示这个页面还没有读进内存 那么这时候页框号其实是无效的，如果有效位为 1 ，就表示这个相应的虚页面的内容已经读入内存了，那么这个页框号就是有效的 

访问位，当要读这个页面或者使用这个页面的时候，由硬件将这一位设置成 1 表示这个页面，在内存的这个页框内容被访问过 

修改位，也就是说 当这个在内存的页框当中的内容被修改了，那么由硬件自动地将这个位设置成 1，如果在内存期间被修改了那么将来还要把它写回到磁盘。 

页面是只读页面，还是可以进行读写操作，那么就通过保护位来设置  

通常情况下，由于地址转换过程是由硬件来完成这个转换，那么硬件需要去访问页表，因此这个页表项的设计通常是由硬件设计的，但是有些计算机可能不是这样，这不是一个必须的

![_config.yml]({{ site.baseurl }}/images/88OS/image333.png)

一个进程的地址空间需要2的20次方个页面，一个页面就有一个页表项，于是我就有 2 的 20 次方个页表项，一个页表项是4 byte ，则一个进程页表项大小为4*2^20=4MB,存储页表项页面大小4kB,则需要1024页表页

![_config.yml]({{ site.baseurl }}/images/88OS/image334.png)

二级页表结构下它的地址转换过程： 

32位的地址空间，有1024个页表页，这里头有一个页目录，每个进程有这么一个页目录，在页目录当中的每一行保存了页表的地址，所以先查找页目录，就得到了页表的地址，然后再从页表当中的页表项得到页框号，我们通过页框号才能够形成真正的物理的内存地址。 

当一个进程上 CPU 的时候，它的页目录的起始地址应该推送到一个特定的寄存器里去，在 X86 的这个体系结构当中，寄存器是 CL3，这个寄存器存放了页目录的起始地址，当这个进程下 CPU 的时候，这个地址就会保存在这个进程的 PCB 相关的现场信息里头，通过这样一个页目录的地址我们就可以找到内存中的页目录 

地址转换过程：一个32 位的虚拟地址空间，页面大小是 4K，页内偏移是占 12 位，前面的页号，把它一分为二，前面 10 位用于页目录的索引或者是代表了它对页目录的一个偏移的一个位置，通过前面这 10 位找到页目录对应的页目录项，找到页目录项之后就得到了页表的地址，然后我们再通过页表的偏移和页表的地址，计算出来页表项的位置，页表项的位置有了以后，我们就有了页框号，那么我们就可以通过这个页框号以及页内偏移经过一个拼接，就形成了真正要访问到的内存的物理地址 或者是代码的这个相应的位置。 

![_config.yml]({{ site.baseurl }}/images/88OS/image335.png)

![_config.yml]({{ site.baseurl }}/images/88OS/image336.png)

![_config.yml]({{ site.baseurl }}/images/88OS/image337.png)
![_config.yml]({{ site.baseurl }}/images/88OS/image338.png)
![_config.yml]({{ site.baseurl }}/images/88OS/image339.png)
![_config.yml]({{ site.baseurl }}/images/88OS/image340.png)

# 3、
# 4、

# 5、
# 6、
# 7、

# 8、