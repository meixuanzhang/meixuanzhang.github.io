---
layout: post
title: week6 同步机制(2)
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、管程的基本概念

![_config.yml]({{ site.baseurl }}/images/88OS/image238.png)  

**管程 MONITOR**(语言机制、条件变量/wait/signal)   

一种新的同步机制:管程   
 
信号量这种机制具有一些缺点，比如说用信号量及 PV 操作解决问题的时候 程序编写需要很高的技巧。 另外如果没有合理地安排 PV 操作的位置，就会导致一些出错的结果 比如说出现死锁等问题。 在上个世纪的 1973 年、 1974 年分别有两位科学家提出了一种新的同步机制,管程.

![_config.yml]({{ site.baseurl }}/images/88OS/image239.png)  

管程里头主要是管理了共享资源所对应的数据结构,管程里头管理共享资源同时提供了在这个共享资源之上需要的各种各样的操作，也就是由一组操作的过程来组成。管程是由共享的数据结构以及在这些数据结构之上一组操作组成

管程里头有一些变量，每个变量有它的自己的作用,然后还有一些过程，比如说生产者、消费者要往缓冲区里头放数据或者是取数据，可以管程中设计成插入和取出这样一些过程。作为进程，它只能通过调用管程给提供的各种过程来间接地来使用管程当中的数据结构。

以这个管程为例,有若干个进程，这些是生产者或者消费者 如果他们要往缓冲区里送数据或者去从缓冲区里读数据的话，就要调用管程当中的 insert 或者是 remove这样一些过程，这就是这些生产者、 消费者进程它通过调用管程提供的过程来对管程里的数据结构进行操作   

![_config.yml]({{ site.baseurl }}/images/88OS/image240.png)  

管程需要解决两个问题，第一个问题是互斥，因为管程管理了一些共享的资源，它要求凡是使用这些资源的进程 只能有一个进程来在对这个数据结构进行相应的操作，也就换句话说 管程是互斥进入的，有一个进程在调用管程里的过程，就不允许其他进程调用。  

管程的互斥是由编译器来负责，因为管程是一个语言机制，那么编译器可以做到。  

第二个要解决的问题是同步问题，通过设置了条件变量 以及在条件变量上实施的 wait 和 signal 操作，也就是等待和唤醒操作 所以条件变量再加上条件变量上实施的这两个操作就可以解决管程的这个同步问题   

两个操作一个是等待一个是唤醒，它的作用是可以使一个进程或者线程，当条件不满足的时候在条件变量上等待，或者通过唤醒操作把得在条件变量上等待的进程或者线程唤醒。 这就是同步要解决的，一个是等待，如果条件不成立需要的信息没到那么需要等待。如果需要的信息到来，那么就需要把这个等待的进程唤醒。 当一个进入管程的进程去执行了等待的操作之后，由于管程是互斥进入的，所以它进入等待了，它要把管程的互斥权或者管程的使用权释放，允许其他的进程进入管程。

![_config.yml]({{ site.baseurl }}/images/88OS/image241.png)  

P等待Q执行，就是说后面进来的这个进程等待，让前面一个进程执行(Hoare 管程)  

P进程唤醒了Q进程,那么Q 进程等待，继续等待，然后P进程执行，我们说等待 比如说 Q 进程等待，它刚才等待的是在条件变量上，那现在就应该在另外一个队列等待 不在一个地方等待。 那么这个方法MESA 管程

![_config.yml]({{ site.baseurl }}/images/88OS/image242.png)  

# 2、HOARE管程 

如果一个进程已经调用了管程当中的某一个过程去做相应的操作， 那么后续的进程就不能再进入管程了，其他还想调用管程过程的进程就只能在管程外面等。 所以门口画了一个队列。

进入管程的进程可能由于对资源的操作的过程中发现条件不成熟， 那么它就不能够继续对资源进行相应的操作。以生产者、 消费者为例。 如果生产者想要调用一个 insert 的过程，去把数据放到缓冲区里头，如果缓冲区满了，那这个放到缓冲区动作是不能完成的，因此这个生产者进程就应该等。 因此为等待不同条件的这样一个进程设置了条件变量，等在某个条件变量上，当一个进程调用wait操作，那么会等在某个条件变量上。  

当一个进程等在条件变量上的时候，它应该把管程的互斥权放开，让管程外的想进入管程的进程进入，如果后面进来的进程，它调用了这些过程去对资源进行相应的操作，在操作过程中发现条件成熟了，所以它调用了signal去唤醒某个等在条件变量上的一个进程。这个 signal 就是做这样的事情。如果唤醒的是刚才等待的这个进程， 那么在管程里头同时有两个进程存在了。 按照HOARE 管程的语义， 后面一个进程唤醒了前面一个进程， 那么前面这个进程执行，而唤醒其他进程的这个进程等待。在管程内设置的一个队列中等待。 它叫紧急等待队列，表示它是管程内这样一个队列

![_config.yml]({{ site.baseurl }}/images/88OS/image243.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image244.png)  

条件变量上实施wait 和 signal 

进程调用wait操作，首先判断紧急等待队列是不是为空。 如果不空，那么就唤醒紧急等待队列上的第一个等待的进程，唤醒前管程的互斥权打开，原来进程进入条件变量等待。如果紧急队列是空的，那么就释放管程的互斥权， 然后这个进程就进入了条件变量的队列的末尾，称之为 c 链的末尾，这是 wait 操作的工作。 

执行signal的时候，首先判断c链上是不是有进程在等。 如果c链为空，没有进程在等，那么这个操作相当于一个空操作。 那么执行这个操作的进程就可以继续执行下去。 但是如果条件变量上这个队列c链上是不空的，就要唤醒其中第一个等待的这个进程。 那么执行这个 signal 操作的进程就要进入到紧急等待队列的末尾，所以它是把别的进程唤醒了之后，它自己进入紧急等待队列的末尾

![_config.yml]({{ site.baseurl }}/images/88OS/image245.png)  

# 3、管程的应用

![_config.yml]({{ site.baseurl }}/images/88OS/image246.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image247.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image248.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image249.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image250.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image251.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image252.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image253.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image254.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image255.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image256.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image257.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image258.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image259.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image250.png) 



# 4、

# 5、

# 6、

# 7、