---
layout: post
title: week6 同步机制(2)
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、管程的基本概念

![_config.yml]({{ site.baseurl }}/images/88OS/image238.png)  

**管程 MONITOR**(语言机制、条件变量/wait/signal)   

一种新的同步机制:管程   
 
信号量这种机制具有一些缺点，比如说用信号量及 PV 操作解决问题的时候 程序编写需要很高的技巧。 另外如果没有合理地安排 PV 操作的位置，就会导致一些出错的结果 比如说出现死锁等问题。 在上个世纪的 1973 年、 1974 年分别有两位科学家提出了一种新的同步机制,管程.

![_config.yml]({{ site.baseurl }}/images/88OS/image239.png)  

管程里头主要是管理了共享资源所对应的数据结构,管程里头管理共享资源同时提供了在这个共享资源之上需要的各种各样的操作，也就是由一组操作的过程来组成。管程是由共享的数据结构以及在这些数据结构之上一组操作组成

管程里头有一些变量，每个变量有它的自己的作用,然后还有一些过程，比如说生产者、消费者要往缓冲区里头放数据或者是取数据，可以管程中设计成插入和取出这样一些过程。作为进程，它只能通过调用管程给提供的各种过程来间接地来使用管程当中的数据结构。

以这个管程为例,有若干个进程，这些是生产者或者消费者 如果他们要往缓冲区里送数据或者去从缓冲区里读数据的话，就要调用管程当中的 insert 或者是 remove这样一些过程，这就是这些生产者、 消费者进程它通过调用管程提供的过程来对管程里的数据结构进行操作   

![_config.yml]({{ site.baseurl }}/images/88OS/image240.png)  

管程需要解决两个问题，第一个问题是互斥，因为管程管理了一些共享的资源，它要求凡是使用这些资源的进程 只能有一个进程来在对这个数据结构进行相应的操作，也就换句话说 管程是互斥进入的，有一个进程在调用管程里的过程，就不允许其他进程调用。  

管程的互斥是由编译器来负责，因为管程是一个语言机制，那么编译器可以做到。  

第二个要解决的问题是同步问题，通过设置了条件变量 以及在条件变量上实施的 wait 和 signal 操作，也就是等待和唤醒操作 所以条件变量再加上条件变量上实施的这两个操作就可以解决管程的这个同步问题   

两个操作一个是等待一个是唤醒，它的作用是可以使一个进程或者线程，当条件不满足的时候在条件变量上等待，或者通过唤醒操作把得在条件变量上等待的进程或者线程唤醒。 这就是同步要解决的，一个是等待，如果条件不成立需要的信息没到那么需要等待。如果需要的信息到来，那么就需要把这个等待的进程唤醒。 当一个进入管程的进程去执行了等待的操作之后，由于管程是互斥进入的，所以它进入等待了，它要把管程的互斥权或者管程的使用权释放，允许其他的进程进入管程。

![_config.yml]({{ site.baseurl }}/images/88OS/image241.png)  

P等待Q执行，就是说后面进来的这个进程等待，让前面一个进程执行(Hoare 管程)  

P进程唤醒了Q进程,那么Q 进程等待，继续等待，然后P进程执行，我们说等待 比如说 Q 进程等待，它刚才等待的是在条件变量上，那现在就应该在另外一个队列等待 不在一个地方等待。 那么这个方法MESA 管程

![_config.yml]({{ site.baseurl }}/images/88OS/image242.png)  

# 2、HOARE管程 

如果一个进程已经调用了管程当中的某一个过程去做相应的操作， 那么后续的进程就不能再进入管程了，其他还想调用管程过程的进程就只能在管程外面等。 所以门口画了一个队列。

进入管程的进程可能由于对资源的操作的过程中发现条件不成熟， 那么它就不能够继续对资源进行相应的操作。以生产者、 消费者为例。 如果生产者想要调用一个 insert 的过程，去把数据放到缓冲区里头，如果缓冲区满了，那这个放到缓冲区动作是不能完成的，因此这个生产者进程就应该等。 因此为等待不同条件的这样一个进程设置了条件变量，等在某个条件变量上，当一个进程调用wait操作，那么会等在某个条件变量上。  

当一个进程等在条件变量上的时候，它应该把管程的互斥权放开，让管程外的想进入管程的进程进入，如果后面进来的进程，它调用了这些过程去对资源进行相应的操作，在操作过程中发现条件成熟了，所以它调用了signal去唤醒某个等在条件变量上的一个进程。这个 signal 就是做这样的事情。如果唤醒的是刚才等待的这个进程， 那么在管程里头同时有两个进程存在了。 按照HOARE 管程的语义， 后面一个进程唤醒了前面一个进程， 那么前面这个进程执行，而唤醒其他进程的这个进程等待。在管程内设置的一个队列中等待。 它叫紧急等待队列，表示它是管程内这样一个队列

![_config.yml]({{ site.baseurl }}/images/88OS/image243.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image244.png)  

条件变量上实施wait 和 signal 

进程调用wait操作，首先判断紧急等待队列是不是为空。 如果不空，那么就唤醒紧急等待队列上的第一个等待的进程，唤醒前管程的互斥权打开，原来进程进入条件变量等待。如果紧急队列是空的，那么就释放管程的互斥权， 然后这个进程就进入了条件变量的队列的末尾，称之为 c 链的末尾，这是 wait 操作的工作。 

执行signal的时候，首先判断c链上是不是有进程在等。 如果c链为空，没有进程在等，那么这个操作相当于一个空操作。 那么执行这个操作的进程就可以继续执行下去。 但是如果条件变量上这个队列c链上是不空的，就要唤醒其中第一个等待的这个进程。 那么执行这个 signal 操作的进程就要进入到紧急等待队列的末尾，所以它是把别的进程唤醒了之后，它自己进入紧急等待队列的末尾

![_config.yml]({{ site.baseurl }}/images/88OS/image245.png)  

# 3、管程的应用

用管程实现生产消费者、JAVA中的类似机制  

第一种途径是直接构造 因为它是语言机制，可以在某个语言当中加入这样一个管程成分，然后编写相应的编译器。第二种是间接构造 也就是如果我已经有了一种同步机制，可以用这种同步机制去构造管程这种新的同步机制，比如说我们已经学过的是信号量及 P、 V 操作，我们完全可以用信号量及 P、 V 操作来构造一个管程 

![_config.yml]({{ site.baseurl }}/images/88OS/image246.png)  

生产者生产了一个产品，它只需要调用管程的相应操作把这个产品放到相应的缓冲区，消费者调用管程相应的操作从缓冲区去取产品，然后做相应的其它操作。在生产者消费者这个问题当中，管程是的设计，首先管程要有一个名字，然后管程里头要有相应的条件变量，当条件不满足的时候，要有一个等待的这样一个条件变量的一个机制，所以这里头设置了两个条件变量，管程还有一些其它的数据结构变量，比如说 count，初值是 0，count记录了这个缓冲区里头有几个数据。

下面就是管程当中的几个典型的操作，两个过程，一个过程是 insert ，往缓冲区里送数据。另外一个是从缓冲区里取数据。它和生产者消费者的一个问题很相似了 比如说，count == N 说明缓冲区满了就要去调用 wait 操作，使得调用这个操作的这个进程处于等待，等在某个条件变量上，wait 到 full 这个条件变量上。当 count == 1 也就是说可能刚才 count 因为等于 0 有消费者来没有取到数据，那么它进入等待状态 那么等到 count = 1 我放了一个数据之后，就把它唤醒了 

remove 也是一样,如果 count == 0 ，没有数据可取，那么等在条件变量 empty 上。如果 count == N- 1 也就是刚才是 N，我取走了一个 count- 1 那么空出来一个缓冲区，那么就可能有其它的进程正好等这个缓冲区，所以要做一个 signal 操作 

![_config.yml]({{ site.baseurl }}/images/88OS/image247.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image248.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image249.png)  

# 4、MESA管程  

Mesa语言中支持了这个管程,主要是针对了 Hoare 管程的一个缺点, Hoare 管程是 p 进程唤醒了 q ，p 进程去等待，让 q 进程执行,这样就会引起一次进程的切换，因为 p 进程要等待让 q 进程上 CPU 执行，当 q 进程执行完了，然后再把 p 进程调度上 CPU，那么 p 进程再来一次切换，所以 Hoare 管程会导致两次额外的进程切换
 
MESA p 进程唤醒了 q，那么 p 进程继续执行，那么 q 进程重新去等待。当然了， q 进程等待等在不同的地方   
 
Hoare 管程用的是 signal，到了 MESA 管程里头改成了 notify  

![_config.yml]({{ site.baseurl }}/images/88OS/image250.png) 

当一个进程检查条件不成立的时候，进入了条件队列里等待，当另外一个进程给它发了一个通知之后，那么这个进程就可以得到通知，然后重新等待不同的地方，等待上 CPU执行了，当它真正被调度上 CPU 的时候，可能会有其他的进程在它之前对条件又重新进行了改变，因此必须重新检查条件 就靠的是用 while 循环来取代 if 语句。 MESA 管程里头使用MESA 语义的话，那么必须用 while 循环来代替这个 if 语句。

位于条件这个队列的第一个进程得到了通知,使得它在将来某个合适的时候(当处理机可用的时候)可以让它上 CPU去执行,它只是得到了通知，没有马上去执行 因此，由于它不是马上执行就不能保证在它下一次上 CPU 的时候 那个条件还依然成立

MESA 管程它的缺点就是会导致对条件变量至少多一次的额外的测试  

![_config.yml]({{ site.baseurl }}/images/88OS/image251.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image252.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image253.png) 

把notify再去改，引入了broadcast   

添加了这批数据,因为长度是不等的，所以不知道到底通知多少个消费者，这次送入的这些数据可能够三个消费者这个使用,也可能是够两个消费者使用， 通过 broadcast 就把所有的等待的这个消费者都给它释放,然后由这些消费者上 CPU 以后重新再去检查条件，重新再去取数据,所以对于生产者而言比较简单。

![_config.yml]({{ site.baseurl }}/images/88OS/image254.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image255.png) 

如何解决互斥问题?这是管程本身机制所决定，也就是它是语言成分，是由编译器来保证的.

如何解决同步问题呢？实际上是通过了条件变量以及在这个条件变量上提供的若干操作，有 wait/signal 或者 wait/notify ，或者 wait/broadcast

![_config.yml]({{ site.baseurl }}/images/88OS/image256.png) 

# 5、PTHREAD中的同步机制

在 Pthread 当中是用一个互斥量,通过对互斥量提供相应的操作来保护临界区。 创建,销毁,加锁，解锁，试图加锁(如果加上了，那么这个锁就锁住了,如果加锁没加上，那我们就可能会去等待,用户编程序的时候可以灵活利用这样一些函数

解决同步问题它就用的是条件变量，以及在条件变量上的各种操作   

![_config.yml]({{ site.baseurl }}/images/88OS/image257.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image258.png) 

这几个互斥量，两个条件变量,使用方法啊和前面是有所不同。首先作为生产者，要往 buffer里头放数据，如果buffer 满了，那就必须等待，所以它这里头调用了cond_wait 函数,在这之前它就用互斥量给加锁,为什么要先加锁？ 因为当一个进程不能继续执行,它要进到等待队列里头，条件变量里头去等待,如果在它没有进入到条件变量队列里头等待，就被切换下CPU，这时候，我们需要用一个锁，来锁住这样一个后续的操作,当中所要使用的数据结构，就是队列,因此先要用 the mutex 来加锁, 然后再去判断条件是不是成立,条件不成立,那只有进入等待，但是注意,进入等待的时候，它必须把这个权力放开，也就是要把锁打开，因此这里头我们看到 cond_wait 的时候，除了对条件变量操作之外，还跟上一个互斥量,而这个互斥量就是在等待的时候应该把锁打开.这就是我们看到用这个 Pthread 这个库的提供的这个机制 来解决生产者消费者问题，和我们前面所说的语言当中的管程机制来解决生产者消费者问题所不同的地方。 

先用一个互斥量或者锁，先上锁，然后再去做相应的工作。条件不成立，进入等待之前它要把这个锁打开 ，这样别的线程才能继续做相应的操作

![_config.yml]({{ site.baseurl }}/images/88OS/image259.png) 

先解锁，解锁完了之后，它会使得这个进程等在条件变量上，条件变量队列里头，然后等到它收到了一个等待的信号的时候，再上锁。所以它是先解锁然后睡眠了，然后再上锁，等到它从睡眠被唤醒以后，第一件事情就是上锁

![_config.yml]({{ site.baseurl }}/images/88OS/image260.png) 

# 6、进程间通信IPC


信号量和管程只能传递很简单的信息，不能传递大量的信息，比如说要把一个大的数组传送给另外一个进程，那么信号量和管程在这一方面是做不到的。 另外管程不适合于用于多处理器的情况，因此我们需要在传递大量信息的时候，引入新的通信机制，那么这个通信机制我们称之为进程间通信机制，其中一个非常典型的形式是消息传递    

![_config.yml]({{ site.baseurl }}/images/88OS/image261.png) 


![_config.yml]({{ site.baseurl }}/images/88OS/image262.png) 

有一个进程要发送消息给另外一个进程，一个进程称之为发送进程，另一个为接收进程。发送进程把消息准备好，由于发送进程它所在自己的地址空间不能够到接收进程地址空间进行任何操作 因此，发送消息这个事情必须由操作系统帮助它来完成，操作系统呢，在它的区域里头设置了一个消息缓冲区，每一个消息都由一个 buffer 来接收这个消息，存放这个消息。 而 buffer 的数据结构它包括了消息的头儿，描述了消息的类型，接收进程的 ID 还有发送进程的 ID ，以及消息的长度和一些控制信息，消息的内容啊，把所有消息内容都可以放在一个 buffer 里头，这是一个等长的消息。 

当发送进程想要把消息发送到另外一个进程的时候，它要调用这个发送原语 send，发送原语实际上是一个陷入了操作系统，由操作系统完成的一个发送的过程，所以陷入内核，然后操作系统接收过来，操作系统主要做的工作就是把发送进程准备好的消息拷贝到某一个缓冲区里头，找一个空的缓冲区，把消息内容拷贝过去，然后把这个消息挂接到接收进程的消息队列的末尾。 PCB里头有很多的数据项，那么其中包括了一个数据项就是，消息队列的指针，通过指针，所有发给这个进程的消息，都挂接到这个队列里头，做完这些事情之后，发送进程其实就是完成了发送工作，

接收进程被调度上 CPU 之后，执行receive 接收原语，陷入操作系统内核，由操作系统来完成相应的工作，因此 操作系统来帮助它把这个消息复制到了，接收进程的地址空间，这样就完成了一个发送的过程，一个接收的过程

发送进程只是把消息准备好 调用 send 操作，那么操作系统做相应的复制消息的内容，挂接的内容，接收进程接收消息的时候呢，也是把这个请求提交给操作系统，操作系统完成把消息复制到接收进程空间的工作

![_config.yml]({{ site.baseurl }}/images/88OS/image263.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image264.png) 

共享内存：需要在物理内存里头建立共享的一块内存空间 并且通过相应的映射，把这个物理内存空间映射到了两个进程相应的地址空间里头。可以看到在进程 1 的这一块空间和进程 2 的这一块空间，都映射到了同一块物理内存，通过这样一个映射，这两个进程其实都是在这块物理内存上做相应的操作。 

这块区域不能同时去写 但是可以同时去读，与前面介绍的 读者、 写者问题类似。 可以利用控制读者、 写者问题的这个方法来解决它们之间的这个互斥问题，当进程 1 要往这个物理内存里头读或者写数据的时候呢，它实际上是往它的那块空间里头去写，因为这个空间映射到了这块物理内存，进程 2 也是一样。  

![_config.yml]({{ site.baseurl }}/images/88OS/image265.png) 

发送进程实际上就是往管道里写，可以有很多发送进程都往管道里写，接收进程实际上就是从管道读，读完了，这些内容就没了。 

![_config.yml]({{ site.baseurl }}/images/88OS/image266.png) 

# 7、典型操作系统中的IPC机制   

Linux的进程兼通信机制，它是继承了 Unix 的相关的内容，就是 Unix 的 IPC，同时Linux还继承系统 5 的 IPC 机制，继承了 BSD 的基于套接字的的 IPC 机制，所以 Linux 继承了 Unix ，系统 5 还有伯克利版本的各种操作系统 IPC 机制。 同时它也是基于 POSIX 的标准的 IPC 机制，设计了 Linux 的 IPC 机制之后，它又增加了它自己的一些进程兼通信机制，消息队列，共享 内存，信号量，信号，套接字，这些实际上是可以用户程序可以使用的，也就换句话说用户程序可以通过接口来完成一些同步，互斥或者是通信等功能，在内核里头，操作系统内核里头有自己需要的同步控制机制，包括了原子操作啊=，自旋锁 读写锁，还有信号量，屏障等等。 

![_config.yml]({{ site.baseurl }}/images/88OS/image267.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image268.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image269.png) 

原子操作它的主要体现在这个操作是不可分割的 在这个操作没有完成之前不会其它的事件、任务被打断。这种原子操作通常会用于对资源的引用技术，因为我们知道有一个变量 I ，把这个变量加 1 ，比如说 I++ 其实这个 I++ 是一条语句，但是到了汇编这一层就是变成多条指令了，因此任何一个指令执行完了都会被中断，即便是 I++ 这么一个很简单的一条语句。 当然有了原子操作，那么对于这种引用技术就可以适用于这些场景 那这里头我们列举出来了各种各样的原子操作。  

![_config.yml]({{ site.baseurl }}/images/88OS/image270.png) 

声明了一个原子类型的这么一个变量 V，它的初值是0 ，可以把这个V加2 ，可以加2，也可以直接加1，有这样一些操作

![_config.yml]({{ site.baseurl }}/images/88OS/image271.png) 

屏障主要用于对一组线程进行协调的。 有一组线程它们共同完成一项任务，那么要求所有的线程都到达了某一个汇合点之后 让它们再一同向前进。 可能有的线程先执行到了这个点，那它就得等着其它的所有的线程都到达了这个汇合点然后再从这个点，再往前出发。

比如说，在矩阵运算当中，要做一个数量非常大的，规模非常大的一个矩阵运算，这个矩阵运算我们可能要做很多次的迭代，在每一次迭代的过程中，由于一个矩阵很大 我们又把这个矩阵，划分成了很多小矩阵，让每一个线程去完成一个小矩阵的计算，每个小矩阵都计算完了，才能进入下一次迭代。 假定有的线程运行得快一点，有的线程运行得慢一点，每个线程都完成了它们这个小矩阵的计算，那么这一次迭代才能算全部完成，这种情况下就可以用这种屏障的机制，来把这些线程让它们达到这个一个汇合点之后再往前走

![_config.yml]({{ site.baseurl }}/images/88OS/image272.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image273.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image274.png) 

