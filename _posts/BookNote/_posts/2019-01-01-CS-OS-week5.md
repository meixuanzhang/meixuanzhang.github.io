---
layout: post
title: week5 同步机制(1)
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、进程的并发执行  

![_config.yml]({{ site.baseurl }}/images/88OS/image200.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image201.png)  

并发指的是进程的执行是一种间断性的,也就是每个进程在它的生命周期期间一会儿上 CPU 执行，一会儿由于某种原因暂停执行,由于这种间断性使得进程的相对执行速度是不可预测的,由于有进程调度，有其他事件的发生，每个进程上 CPU 可能执行一段时间停止，然后再接着执行，所以整个执行的时间是不可预测的   

在一个并发环境下多个进程或者线程之间会共享某些资源，那么在这些资源的使用过程中，它会产生进程之间的一种制约性 比如说当一个进程享用打印机这个资源 那么另外一个进程在第一个进程没有释放这个资源的前提之下，那么就得不到这个资源，那就得等待。因此在一个并发环境下，多个进程的执行会带来一种制约。

进程的执行结果和它的相对执行速度是有关系的，因此 在不同的执行顺序的情况下，那么进程的执行结果也是不确定的   

![_config.yml]({{ site.baseurl }}/images/88OS/image202.png)  

在写回去的时候不管是 T1 先写回去，还是 T2 先写回去，如果我们没有对这个账户加以控制使得 T1、 T2 这两个程序当中的一些关键活动 出现了交叉，那么就可能会出现与时间有关的错误。   

比如说 T1 先把 x 的值减完 1000 之后，再把它写回到账户上 那么这个时候账户上应该是 4000 元，可是 T2 因为刚才已经把 5000 元读到了 x，所以对 x 减去 2000 之后，那么再把它写回去的时候，就是相当于把 3000 元写回去 那么当然如果反过来，T2 先写 回去，T1 再写，那么账户上的余额呢就变成 4000 元，由于这两个进程它们的关键活动 中间出现了交叉，因此账户上的余额是不对的

![_config.yml]({{ site.baseurl }}/images/88OS/image203.png)  

f 缓冲区和 g 缓冲区可以分别存放多个数据，而 s 和 t 缓冲区呢只能放一个数据。  

这三个进程呢都是循环执行的 第一个进程get 的工作是把 f 里头的数据取一个送到 s 里，copy 是从 s 里取一个数据送到 t 里 而 put 是从 t 里头取一个数据往 g 里去送。假设 get 可以循环很多次 当它第一个把数据读到了 s 里头以后，那么再读第二次的时候 由于 s 里的数据假设还没有被 copy 给取走，那么第二次往 s 里送的数据实际上就把前面送的数据给覆盖掉了。为什么会出现这种情况？因为我们这是一个在一个并发环境下执行的，任何一个进程都可能会被调度上 CPU，那么也可能会出现 put 先被调度上 CPU，而 t 里的内容还没有准备好，那么就可能说把一个不需要的数据送到了这个 g 缓冲区，所以这是可能会出现各种各样的情况。

![_config.yml]({{ site.baseurl }}/images/88OS/image204.png)  

我们假设 g,c,p 分别为 get,copy 和 put 的一次循环，因此从当前状态出发，我们可能有这样一种组合的执行过程。 那么 get, copy put 各执行一个循环，那么得到的结果就是把 3 这个数据运到了送到了g 里头去，这是一个正确的结果，因为 s 和 t 里头分别也放了是 3 这个数据，但是如果还从这样一个当前状态出发，如果是 g,p,c 这样一个执行的轨迹，我们会看到最后 g 这个缓冲区里头得到的是 1,2,2 ，前面的几个缓冲区数据是对的，但是这个结果就是错的，这是一种错误的情况

在一个并发环境下 三个并发的进程在执行过程中由于调度，其他的因素会造成错误

![_config.yml]({{ site.baseurl }}/images/88OS/image205.png)  

这三个进程它们之间是有制约关系的 而没有满足这种制约关系就会出现刚才的错误。现在我们来看一看这三个进程的制约关系是什么样子的

这三个进程的制约关系是什么样子的，用一个进程的前趋图来表示，那么 g1 代表的是get执行第一个循环，c1表示的是 copy 执行的第一个循环。 那么我们可以看到当 get 执行完第一个循环之后，只能够 copy 执行它的第一个循环。 当 copy 执行完第一个循环之后，那么后面是 put 执行第一个循环，还是 get 执行第二个循环，都可以，这两个可以顺序可以颠倒，可以任意的顺序。 但是它们两都执行完了，才能够去执行 copy 的第二个循环。因此这三个进程它们之间的这种制约关系应该满足这样一个前趋图，这样才能保证不出错误

![_config.yml]({{ site.baseurl }}/images/88OS/image206.png)  

# 2、进程互斥

引入“竞争条件”概念，这张图反映了一个 Spooling 技术用于打印机，其需要维护一个打印的目录Spooler，有一个打印机的守护进程随时看管这个目录，这里头存放了所有的进程，需要打印的这种文件的文件名。当这个缓冲区里头有文件名的时候，打印进程就工作，没有文件名的时候，打印机可以去睡眠。 

对于这样一个目录，需要用一个 in 这个变量来表示当前哪一个缓冲区的槽是空的，那么进程可以把要打印的文件名送入到这个槽中。假设有这么一个情况，进程 A 和进程 B 都需要打印了，假如说进程 A 它先从 in 这个变量里读到了当前的这个，可以存放文件名的索引，比如说是 7 ，那么把它这个值读入到自己的这个局部变量里头，然后它就去把文件名送到了这个7对应单元，那么这个时候它应该把7更新到8，可是在这个更新之前，进程A被切换下 CPU，它还没有把 in 更新成更新为 8 ，它下 CPU 之后 假如说进程 B 要上 CPU，它也要打印，从 in 里头得到了一个 7 这个值 因此，进程 B 就会把它要打印的文件名也送到 7 对应的单元，把刚才进程 A 送的那个文件名就覆盖掉了，进程 B 把 in 改成 8 之后，去做别的事情去了，因此进程 A 就再也得不到自己的打印的结果了 

竞争条件的定义是：就是说两个或多个进程在读写某些共享数据的时候，这个 in 就是共享数据 而最后的结果取决于进程运行的一个精确的时序，就是时间序列，就是它跟时间是相关的 这就是带来了竞争条件。所以竞争条件是由于有这样一个共享的资源，共享的数据，而多个进程都对这个数据进行相应的操作带来的  

![_config.yml]({{ site.baseurl }}/images/88OS/image207.png)  

进程互斥：由于在一个并发环境里头多个进程都要使用一些共享资源，像一些变量啊、文件，这些资源具有这样一个性质，它需要排他性的使用，也就是说我用那么另外一个进程就不能用，因此，各个进程之间对这个资源的使用是一种竞争，这种竞争称之为进程的互斥。

当一个进程用，另外一个进程用不了，那么这个共享资源给它起了一个名字叫做临界资源，有的时候也叫互斥资源 它的特点是一次只能给一个进程使用，那么当多个进程都要使用同一个共享资源的时候，它的代码里头会有相应的操作，这些代码叫做临界区，也叫互斥区，所谓临界区和互斥区是多个进程当中，对某一个共享变量，或者临界资源实施操作的**程序片段**，这些程序片段分散在不同的进程里头，那么它们的共同的特点，是对同一个共享变量进行一些操作，那么这一段代码和另外一个进程的这一段代码，他们互为临界区，互为互斥区

![_config.yml]({{ site.baseurl }}/images/88OS/image208.png)  

有了互斥区之后，我们会看到在互斥区的使用上，是要满足一定的条件的。比如说，当 A 进程进入临界区，在临界区里头，还没有出临界区的时候，如果B进程上CPU之后也想进临界区，应该不能够让B进去，因为如果B进程也进临界区，就会出现关键活动的交叉，就会出现前面我们所介绍的各种各样带来的错误 因此，当 B 进程想要进临界区的时候，由于 A 进程还在临界区里头没有出来，所以 B 进程只能够被阻塞，不能进临界区。上一讲我们所介绍的优先级反转问题，一个低优先级的进程进到了临界区，那么这个时候因为它优先级比较低，那么有更高优先级的进程就绪的时候，就会抢占它的CPU ，但更高优先级的进程需要进入临界区，可是低优先级的进程在临界区里头，它进不了这个临界区，也就上不了CPU 运行，所以就被阻塞。而在高优先级和低优先级 之间，又源源不断的会有一些中级优先级的，但是又非常耗时的这样的一些进程在执行，使得低优先级的进程上不了 CPU ，也就不能够让高优先级的进程尽快上 CPU ，因为它被阻塞    

等到 A 进程离开临界区 B 进程才能够进入它的那段代码

![_config.yml]({{ site.baseurl }}/images/88OS/image209.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image210.png)  

# 3、进程互斥的软件解决方案

# 4、

# 5、

# 6、

# 7、

# 8、