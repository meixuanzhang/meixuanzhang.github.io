---
layout: post
title: week5 同步机制(1)
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、进程的并发执行  

![_config.yml]({{ site.baseurl }}/images/88OS/image200.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image201.png)  

并发指的是进程的执行是一种间断性的,也就是每个进程在它的生命周期期间一会儿上 CPU 执行，一会儿由于某种原因暂停执行,由于这种间断性使得进程的相对执行速度是不可预测的,由于有进程调度，有其他事件的发生，每个进程上 CPU 可能执行一段时间停止，然后再接着执行，所以整个执行的时间是不可预测的   

在一个并发环境下多个进程或者线程之间会共享某些资源，那么在这些资源的使用过程中，它会产生进程之间的一种制约性 比如说当一个进程享用打印机这个资源 那么另外一个进程在第一个进程没有释放这个资源的前提之下，那么就得不到这个资源，那就得等待。因此在一个并发环境下，多个进程的执行会带来一种制约。

进程的执行结果和它的相对执行速度是有关系的，因此 在不同的执行顺序的情况下，那么进程的执行结果也是不确定的   

![_config.yml]({{ site.baseurl }}/images/88OS/image202.png)  

在写回去的时候不管是 T1 先写回去，还是 T2 先写回去，如果我们没有对这个账户加以控制使得 T1、 T2 这两个程序当中的一些关键活动 出现了交叉，那么就可能会出现与时间有关的错误。   

比如说 T1 先把 x 的值减完 1000 之后，再把它写回到账户上 那么这个时候账户上应该是 4000 元，可是 T2 因为刚才已经把 5000 元读到了 x，所以对 x 减去 2000 之后，那么再把它写回去的时候，就是相当于把 3000 元写回去 那么当然如果反过来，T2 先写 回去，T1 再写，那么账户上的余额呢就变成 4000 元，由于这两个进程它们的关键活动 中间出现了交叉，因此账户上的余额是不对的

![_config.yml]({{ site.baseurl }}/images/88OS/image203.png)  

f 缓冲区和 g 缓冲区可以分别存放多个数据，而 s 和 t 缓冲区呢只能放一个数据。  

这三个进程呢都是循环执行的 第一个进程get 的工作是把 f 里头的数据取一个送到 s 里，copy 是从 s 里取一个数据送到 t 里 而 put 是从 t 里头取一个数据往 g 里去送。假设 get 可以循环很多次 当它第一个把数据读到了 s 里头以后，那么再读第二次的时候 由于 s 里的数据假设还没有被 copy 给取走，那么第二次往 s 里送的数据实际上就把前面送的数据给覆盖掉了。为什么会出现这种情况？因为我们这是一个在一个并发环境下执行的，任何一个进程都可能会被调度上 CPU，那么也可能会出现 put 先被调度上 CPU，而 t 里的内容还没有准备好，那么就可能说把一个不需要的数据送到了这个 g 缓冲区，所以这是可能会出现各种各样的情况。

![_config.yml]({{ site.baseurl }}/images/88OS/image204.png)  

我们假设 g,c,p 分别为 get,copy 和 put 的一次循环，因此从当前状态出发，我们可能有这样一种组合的执行过程。 那么 get, copy put 各执行一个循环，那么得到的结果就是把 3 这个数据运到了送到了g 里头去，这是一个正确的结果，因为 s 和 t 里头分别也放了是 3 这个数据，但是如果还从这样一个当前状态出发，如果是 g,p,c 这样一个执行的轨迹，我们会看到最后 g 这个缓冲区里头得到的是 1,2,2 ，前面的几个缓冲区数据是对的，但是这个结果就是错的，这是一种错误的情况

在一个并发环境下 三个并发的进程在执行过程中由于调度，其他的因素会造成错误

![_config.yml]({{ site.baseurl }}/images/88OS/image205.png)  

这三个进程它们之间是有制约关系的 而没有满足这种制约关系就会出现刚才的错误。现在我们来看一看这三个进程的制约关系是什么样子的

这三个进程的制约关系是什么样子的，用一个进程的前趋图来表示，那么 g1 代表的是get执行第一个循环，c1表示的是 copy 执行的第一个循环。 那么我们可以看到当 get 执行完第一个循环之后，只能够 copy 执行它的第一个循环。 当 copy 执行完第一个循环之后，那么后面是 put 执行第一个循环，还是 get 执行第二个循环，都可以，这两个可以顺序可以颠倒，可以任意的顺序。 但是它们两都执行完了，才能够去执行 copy 的第二个循环。因此这三个进程它们之间的这种制约关系应该满足这样一个前趋图，这样才能保证不出错误

![_config.yml]({{ site.baseurl }}/images/88OS/image206.png)  

# 2、进程互斥

引入“竞争条件”概念，这张图反映了一个 Spooling 技术用于打印机，其需要维护一个打印的目录Spooler，有一个打印机的守护进程随时看管这个目录，这里头存放了所有的进程，需要打印的这种文件的文件名。当这个缓冲区里头有文件名的时候，打印进程就工作，没有文件名的时候，打印机可以去睡眠。 

对于这样一个目录，需要用一个 in 这个变量来表示当前哪一个缓冲区的槽是空的，那么进程可以把要打印的文件名送入到这个槽中。假设有这么一个情况，进程 A 和进程 B 都需要打印了，假如说进程 A 它先从 in 这个变量里读到了当前的这个，可以存放文件名的索引，比如说是 7 ，那么把它这个值读入到自己的这个局部变量里头，然后它就去把文件名送到了这个7对应单元，那么这个时候它应该把7更新到8，可是在这个更新之前，进程A被切换下 CPU，它还没有把 in 更新成更新为 8 ，它下 CPU 之后 假如说进程 B 要上 CPU，它也要打印，从 in 里头得到了一个 7 这个值 因此，进程 B 就会把它要打印的文件名也送到 7 对应的单元，把刚才进程 A 送的那个文件名就覆盖掉了，进程 B 把 in 改成 8 之后，去做别的事情去了，因此进程 A 就再也得不到自己的打印的结果了 

竞争条件的定义是：就是说两个或多个进程在读写某些共享数据的时候，这个 in 就是共享数据 而最后的结果取决于进程运行的一个精确的时序，就是时间序列，就是它跟时间是相关的 这就是带来了竞争条件。所以竞争条件是由于有这样一个共享的资源，共享的数据，而多个进程都对这个数据进行相应的操作带来的  

![_config.yml]({{ site.baseurl }}/images/88OS/image207.png)  

进程互斥：由于在一个并发环境里头多个进程都要使用一些共享资源，像一些变量啊、文件，这些资源具有这样一个性质，它需要排他性的使用，也就是说我用那么另外一个进程就不能用，因此，各个进程之间对这个资源的使用是一种竞争，这种竞争称之为进程的互斥。

当一个进程用，另外一个进程用不了，那么这个共享资源给它起了一个名字叫做临界资源，有的时候也叫互斥资源 它的特点是一次只能给一个进程使用，那么当多个进程都要使用同一个共享资源的时候，它的代码里头会有相应的操作，这些代码叫做临界区，也叫互斥区，所谓临界区和互斥区是多个进程当中，对某一个共享变量，或者临界资源实施操作的**程序片段**，这些程序片段分散在不同的进程里头，那么它们的共同的特点，是对同一个共享变量进行一些操作，那么这一段代码和另外一个进程的这一段代码，他们互为临界区，互为互斥区

![_config.yml]({{ site.baseurl }}/images/88OS/image208.png)  

有了互斥区之后，我们会看到在互斥区的使用上，是要满足一定的条件的。比如说，当 A 进程进入临界区，在临界区里头，还没有出临界区的时候，如果B进程上CPU之后也想进临界区，应该不能够让B进去，因为如果B进程也进临界区，就会出现关键活动的交叉，就会出现前面我们所介绍的各种各样带来的错误 因此，当 B 进程想要进临界区的时候，由于 A 进程还在临界区里头没有出来，所以 B 进程只能够被阻塞，不能进临界区。上一讲我们所介绍的优先级反转问题，一个低优先级的进程进到了临界区，那么这个时候因为它优先级比较低，那么有更高优先级的进程就绪的时候，就会抢占它的CPU ，但更高优先级的进程需要进入临界区，可是低优先级的进程在临界区里头，它进不了这个临界区，也就上不了CPU 运行，所以就被阻塞。而在高优先级和低优先级 之间，又源源不断的会有一些中级优先级的，但是又非常耗时的这样的一些进程在执行，使得低优先级的进程上不了 CPU ，也就不能够让高优先级的进程尽快上 CPU ，因为它被阻塞    

等到 A 进程离开临界区 B 进程才能够进入它的那段代码

![_config.yml]({{ site.baseurl }}/images/88OS/image209.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image210.png)  

# 3、进程互斥的软件解决方案   

free来代表临界区是否空闲,如果free等于true，就表示说有进程在临界区，如果free等于false ，就表示说临界区是空闲的。现在有两个进程当它们都想进临界区的时候，首先要做的事情是要判断一下 free 这个标志，如果 free 这个标志是 false，那么这个循环while(free)就结束，进到下面一条语句，也就是把这个标志设置为true，表示有进程在临界区，假设 P 先上的 CPU，因为 free 的初值是 false ，所以这个循环就结束了,如果这个时候进程 P 被切换下 CPU ，P 还没有来得及改变free的值,正好下面上 CPU 的进程 Q 它也要判断 free 的这个标志是不是 false ，由于进程 P 还没有来得及改变它的值，因此检测的结果是 free 也等于 false ，所以它继续往下走把 free 变成 true ，然后进入了临界区。如果 Q 进入临界区之后又一次被切换下去了，在这个时候P 上 CPU 了，把 free 变成 true ，然后进入临界区，那么两个进程都在临界区，这是一个错误的解法    

可以把图中两条语句写成一个 lock 函数，如果把 lock 函数的这个执行设计成一个原语，也就是在执行过程中不容许被中断，那么这个操作就是正确的了。同样free 等于 false ，也把它封装成一个解锁的函数，也是一个原语操作，虽然是一条语句，但这条语句变成了指令一级的话，会变成多条指令。 所以，同样我们需要把 unlock 这个函数啊，设计成一个原语

![_config.yml]({{ site.baseurl }}/images/88OS/image211.png) 

设置了一个turn标志，如果等于 true 表示 让 P 进程进临界区，如果 turn 等于 false 就让 Q 进程进临界区。初值是任意，那么可能会出现这样一个场景，就是说 P 进程想进临界区，由于 turn 等于 false ，所以进不去， 所以 P 进程老在那等待进入临界区，它在那循环。 可是如果 Q 进程始终没有进过临界区，也不想进临界区，那么 P 进程就进不了临界区，尽管临界区里头没有进程 也就是说，在临界区外的进程 Q 阻止了 P 进程进临界区，这是不容许的，这也是违反我们前面所介绍的使用临界区的原则   

![_config.yml]({{ site.baseurl }}/images/88OS/image212.png)   

进临界区它的条件判断是，P进程要想进临界区，首先 pturn等于true ，然后qturn 呢不等于 true，这样P进程可以进临界区，同样Q进程也是要判断自己想进临界区并且对方不想进临界区的时候。如果P进程上CPU了，那么pturn等于true ，假设 P 进程又被切换下去了，当Q 进程上CPU，也想进临界区，qturn等于 true ，接着Q 进程会去判断能不能进，可是刚才由于P进程已经设置 pturn 等于 true 了，所以Q进程就会在这不断的循环，时间片到了Q 进程被切换下CPU，假设 P 进程又上 CPU 了，要判断 Q 进程想不想进临界区，Q进程是想进临界区的，所以P进程也不进临界区，临界区是没有进程在里头的，而P进程和Q进程也都不进临界区，两个进程不断的在这循环，谁都不去进临界区。这么一个场景称为 after you 问题，就大家都在谦让，谁也不进临界区，这也不满足临界区的使用原则

![_config.yml]({{ site.baseurl }}/images/88OS/image213.png)  

刚才算法3的基础之上，又引入了一个turn变量，这个turn变量是相当于是一个枚举类型，在两个进程都想进又都谦让的这种情况下，由 turn 来决定谁进   

这两条语句while(turn==)就是说在在让出CPU之后还要保持不断的循环去判断是不是该轮到自己了，因此这里有一个循环直到它把它的时间片用完,然后被切换下 CPU，始终在 CPU 上在循环,我们称之为叫忙等待 busy waiting

一个CPU时，没有其他进程上CPU，则必须在CPU用完了时间片才能被切换下去，所以浪费了这些时间，这就是 DEKKER 算法

![_config.yml]({{ site.baseurl }}/images/88OS/image214.png)  

PETERSON 算法解决了互斥访问问题，同时克服了DEKKER 算法强制轮流的缺点，方案对于开发的用户非常容易使用的。  
 
任何一个进程当它想进临界区的时候，它只需要调用一个 enter_region函数 来看一看能不能安全地进入临界区，如果能安全地进入临界区，那么就是相当于这个函数执行结束，它就可以进临界区了。如果不能够安全地进入临界区，那么它就在这个函数当中去等待进入临界区。 当进程使用完临界区的相关资源之后，出临界区的时候调用一个 leave_region，那么也就是可以让其他的进程进入临界区。 

enter_region函数设计：  

这个代码当中interested 是一个数组，它是表示出哪个进程想进临界区，要把这个意愿表达写在这个数组的某个单元里头，假设我们有两个进程，进程号是0和1，另外一个进程的编号other就是1减去当前这个进程的进程号 然后在这个数组里头表达进程想进临界区，把这个单元设置成true，在此之后有一个非常重要的变量turn，当前的这个进程进程号赋给这个 turn ，那么谁要想进临界区，就用自己的进程号赋给这个turn，如果两个进程同时想进临界区，大家都可以往里头赋值，比如说 0 和 1 都想进临界区，那就看谁先赋值给 turn，谁后赋值给 turn ，我们假设 0 号进程先赋值给 turn 那么后，后面的是 1 号进程赋值给 turn，先赋值给 turn 的那个值实际上就被后面赋值的这个覆盖掉了，所以 turn 里头始终保持是后面要想进临界区的进程的进程号

两个进程都想进，希望谁先来的谁先进，也就是谁先给 turn 赋值，谁先进临界区。 这有一个判断，turn 等不等于 process，process是当前这个进程的进程号，如果你是要先进临界区，假设turn 的值后面已经被后面那个进程给覆盖掉了，现在 turn 不等于 0 了，这个条件不成立，循环就结束了，换句话说，0号进程循环一次都没有做就出来了进临界区，1 号进程是后把这个进程号赋给这个 turn 的，所以turn 的值就等于 1 ，两个条件都成立，所以进程 1 调用了enter_region，实际上是在做循环。

![_config.yml]({{ site.baseurl }}/images/88OS/image215.png)  

# 4、进程互斥的硬件解决方案  

开关中断指令实际上是允许中断或禁止中断，这样一条指令 也就是在进临界区之前，我们先把中断关闭，屏蔽掉禁止，然后就进入临界区做相应的操作，出临界区的时候再把中断打开，允许中断，实际上原语操作都是用这样一种方式来实现的，所以临界区的保护也可以用开关中断这样一个指令来实现

这种实现方法非常的简单，非常的高效，但是它的代价也很高，临界区的区域 如果设置的比较大，范围划定的比较大 就会限制CPU 的这种并发能力，有些指令执行的时候就没有并发执行。 中断指令只适合于用于单处理器，开关中断或者是禁止或者允许中断只针对一个处理器 它对其它处理器是没有效果的。 也就是说一个 CPU 不可以接收中断，并不意味着其它CPU 不可以接收中断，最后用户程序是不能用的，用户进程是不能使用这个特权指令的 因此，用户程序它不能够直接在代码里头是允许开中断 或者关中断，只能够操作系统来用，所以操作系统很多地方都是采用这种方法来达到目的的   

![_config.yml]({{ site.baseurl }}/images/88OS/image216.png)  

硬件的第二种解法是用一条特殊的指令：测试并加锁指令，它实际上是这一条指令做了两个事情，一个是先读，把一个内存单元内容读到寄存器，然后再去写，把内存单元的内容写上某个值， TSL 这条指令是复制锁到寄存器，然后并且把锁置成 1，这个 Lock 是一个内存单元，把它内容先复制到了寄存器，然后再把这内存单元的值设置成 1，那么就是说原来这个内存单元原来要如果是0，那么寄存器里内容就是 0。 如果原来已经是 1 了，也就说已经上了锁，接着判断一下寄存器的内容是不是 0，如果是 0 说明原来的是没上锁的，你锁上就可以进入临界区了。 如果不是 0 那就要去再次做测试，所以要反复测试，这就是 TSL 指令实现的一段 代码，这段代码相当于加锁这样一个功能。就是说这件事情从内存单元读一个值到寄存器，再往内存单元写。

实际上是通过把总线封锁，先读后写的这个操作都完了，再把总线打开，因此这条指令是在总线一级上做了一些工作，然后达到了这个结果。这里头有一个循环，如果不是 0，也就是原来是上锁的，那么就跳到了这个，一个标志的地方，然后再去判断是不是 0，这也是一个 busy waiting，也是一个反复循环的过程，直到 这个单元变成 0 为止  

![_config.yml]({{ site.baseurl }}/images/88OS/image217.png)  

交换指令的作用是把两个位置，可能是寄存器或者是内存单元，只是两个位置的内容在一条指令结束的时候，把两个位置进行一个交换，也是实现一个加锁这么一个过程，首先先给寄存器当中设置成 1，然后交换寄存器和锁变量，通过这个交换就把这 1 设置给锁变量了，那么原来锁变量里头是 0 或者 1 的值，就送到了寄存器，然后再接着去判断，跟前面 TSL 指令是一样的，解锁实际上就是一个 move 语句，把这个内容复制成 0 就可以了。 

硬件解决方案就是用指令 特殊的一些指令来达到保护临界区的目的

![_config.yml]({{ site.baseurl }}/images/88OS/image218.png)  

软件解法对编程的技巧要求比较高，一般的开发人员不愿意做这些事情的。如果考虑不周到可能还会出现一些逻辑性的错误，很难查出来

硬件解法主要是通过指令 像开关中断指令，测试并设置加锁指令，或者交换指令，解决相应的保护问题   

软件的解法和硬件解法当中，多次看到了这样一个循环的存在，而这个循环不断测试这个锁是不是打开了，或者是测试条件是不是成立，在 CPU上一直在做测试，这种测试呢我们称之为忙等待

忙等待就是进程在得到临界区的访问之前，持续做测试 不做任何其他的事情，浪费了 CPU 的周期

在单 CPU 的系统当中不是一个好的解决方案，因为如果你占着 CPU 那么其它进程上不了 CPU，是没办法把相应的资源还回来的，所以在单处理器系统中应该把这种方案给它这个抛弃。 

到了多处理器的时候，由于有多个处理器，所以某一个内存单元，它的值从 1 变成 0，可以由另外一个处理器 CPU 来完成这项工作，所以某一个进程上了一个 CPU，想要进入临界区，在这个锁或临界区的访问权没有得到之前，它可以一直在保持测试 但是其它的 CPU 会去运行相应的进程，去把这个锁打开或者是把临界区还回来。为什么不下 CPU ，因为切换实际上会带来开销的，临界区的使用应该是个很短的时间，所以很快就会有进程把临界区让过来，在这种情况下一个进程在某一个 CPU 上持续做测试这是允许的，因为切换的开销比这个还要大  

在多处理器情况下又把忙等待这种思路又引进来，那么就形成了一种特定的锁，叫做自旋锁，Spin lock 这个锁就是说如果我想得到临界区使用权，那么我首先要判断是不是有进程在临界区，如果有进程在临界区，那我就在那里自旋，不断地去测试直到这个临界区还回来，在多处理器的情况下，这个自旋锁是常用的一种进入临界区的一个方法 

那么临界区的问题会带来优先级反转，基于优先级的抢占式的调度 可能会导致优先级反转现象的产生 而这个反转现象的产生呢，其主要的一个原因可能就是临界区的使用，由于临界区的这个保护，而带来的一个优先级反转问题

![_config.yml]({{ site.baseurl }}/images/88OS/image219.png)  


# 5、进程同步  

刚才介绍的 get,copy 和 put 这三个进程，它们就是一种同步关系

![_config.yml]({{ site.baseurl }}/images/88OS/image220.png)  

看一个进程同步问题，把进程分成两类 一类叫做生产者进程，一类叫做消费者进程，那么它们都对一个 buffer进行相应的操作，因为有一个 buffer 介入，所以有时候也称为有界缓冲区域问题。这个问题是场景是这样的，一个或多个生产者，它生产了某种数据、某种信息，然后要把这个数据或者信息存放在缓冲区当中，而消费者主要工作是从这个缓冲区当中取走相应的数据，然后每次取一个。如果两个进程，一个生产者进程，一个消费者进程同时要对一个 buffer 操作，这是不允许的，这是对 buffer 的一个保护。所以这里头我们就会看到当中实际上有三个问题： 

当缓冲区已经满了的时候，后续的生产者进程就不能够再继续往 buffer 里送

如果 buffer是空的消费者上CPU 执行应该是取不到任何数据的，所以当缓冲区域是空的时候，消费者不会从缓冲区域中取数据 

生产者进程和消费者进程不能同时对一个 buffer 进行操作，那么这个问题怎么解决。 前面已经讲过了，要避免忙等待，就是说当发现这个条件不成立，不能够继续执行的时候，不会去在那循环地做测试，会让出 CPU，所以设计了两个操作 一个呢叫睡眠，另外一个是唤醒，另外一个进程做完了相应的工作之后，把刚才进入睡眠的这个进程唤醒。

![_config.yml]({{ site.baseurl }}/images/88OS/image221.png)  

对于生产者首先要做的事情是生产一个产品，把这个数据放到一个变量item里头,然后下面要做的事情是要把这个数据送到缓冲区里头，但是它要看缓冲区是不是满了，如果满了就不能送了，所以用count 来表示缓冲区里头现在已经装了多少数据的个数，count 初值是 0，然后每送一个加 1，如果 count = N，也就是缓冲区满了，这个时候生产者就要睡眠，调用 sleep 来睡眠,消费者也是一样，如果消费者上 CPU ,首先要判断有没有数据可以取到，如果count 是0,没有数据可以取，它也调用 sleep，然后睡眠。当一个进程睡眠就必须有另外一个进程把它从睡眠状态变成就绪状态，当生产者往 buffer 里放了一个数据之后，这个 count 加 1，原来count是0 ，加完 1 之后,缓冲区里就有数据了，所以判断一下，如果 count = 1，因为刚才它是 0 而睡眠,现在count 等于 1 ，就要做一个 wakeup 操作 所以生产者有义务把某个消费者唤醒。 消费者同理。

如果在它判断它count = 0还没有去调用 sleep 之前，消费者被切换下 CPU，那么这个时候 count 是 0 ，假设生产者又生产了一个数据，可以看到就不断地去生产，这里头我们可以看到刚才是 0，现在生产者生产了一个数据之后加完 1 之后，count 就等于 1 了，所以做了一个 wakeup ，由于刚才消费者还没有 sleep，所以这个 wakeup 实际上做了一个空操作，因为没有进程在睡眠，所以就继续接着执行，生产者继续生产，如果生产者被切换下 CPU，消费者一上来肯定首先要做的事情先做 sleep，由于进程刚才 wakeup 已经做完了，所以就不会再被唤醒了

![_config.yml]({{ site.baseurl }}/images/88OS/image222.png)  

SPOOLing系统当中有很多的进程，比如说有输入进程，有作业调度，有作业控制进程，还有输出进程，输入进程把批处理的作业往送往输入井，输入井的这个区域设置的是一个有限的区域，源源不断的作业来了之后，就把输入井填满了，输入井如果填满了，那么输出进程实际上就不能再往里头送东西了，输入程序在这里就是生产者的作用。而作业调度程序实际上就是一个消费者 如果没有作业进入输入井，那么调度程序也没有可选的，所以它也要睡眠。 

因此在这里头，输入程序、 作业调度是一对生产者/消费者，同样的道理 我们看到作业控制进程实际上是和输出进程，也是一对生产者和消费者，这个 buffer 缓冲区实际上就是输出井。作业调度和作业控制进程它也可以看成是一对生产者和消费者，这是一个 SPOOLing 技术当中，我们可以看到生产者/消费者的一个影子

![_config.yml]({{ site.baseurl }}/images/88OS/image223.png)  

这有8个进程，P1 一直到 P8，这 8 个 进程必须满足这样一个关系：P1 全部执行完了 P2，P3，P6 才能执行，然后 P3 执行完了，P4，P5 才能执行 P2，P4，P5，P6 都执行完了，才能够 P7 或者 P8，它们两有一个执行。它们两可以同时，或先后执行，谁先执行都无所谓 但是必须要求 P2，P4，P5，P6 都执行完了 那么也就是说当 P1 到 P8 这 8 个进程 同时并发在系统中执行的过程中，谁都可能先上 CPU 那么你要满足这个同步关系，就不能在其他都没执行完的时候P8 就执行了，这就是典型的在进程之间的一个同步问题  

前面例子实际上是进程的中间的某个事件和另外一个进程的某个事件的一个同步关系

![_config.yml]({{ site.baseurl }}/images/88OS/image224.png)  

# 6、信号量及PV操作   

介绍一种非常经典的进程的同步机制，之所以叫同步机制，是因为通常把进程的互斥看成是一种特殊的同步。我们就称之为同步机制，它既解决同步的问题，也能解决互斥的问题，典型的进程的同步机制称之为信号量及 P、V 操作。

信号量是一种特殊的变量，它实际上是用于进程之间传递信息的一个整数值 信号量它由一个值和一个队列组成 那么也就是这个值是你要传递的一个传递信息的整数值 而队列是允许进程挂到这个队列上的。 

![_config.yml]({{ site.baseurl }}/images/88OS/image225.png)  

p操作如果count小于0，那么这个进程的状态就变成了阻塞态，谁调用了 P 操作，这个进程的状态变成阻塞态，并且把它送到相应的等待队列的末尾，也就是信号量上有一个队列的末尾，这个进程实际上就让出了 CPU，接着就要重新调度选另外一个进程上 CPU 了  

V 操作实际上是信号量的值加 1，如果信号量小于等于 0 ，说明原来这个信号量上有进程在等，因此就唤醒这个信号量队列上等待的这个进程，把这个进程的状态改成就绪态，把它送到就绪队列，然后执行 V 操作的进程可以继续执行

![_config.yml]({{ site.baseurl }}/images/88OS/image226.png)  

P 操作和 V 操作是原语操作，也是原子操作，在执行过程中不允许被中断，刚才所介绍的那一段代码，实际上是在执行过程中把中断关闭，然后执行，然后再打开中断   

首次提出这个信号量这个概念的时候呢 他叫的二元信号量，也就是两个值0或者是1，当初用来解决的是互斥问题，后来发现如果把信号量的值从0和1可以往正数推，或者是往负数，给它扩大，这叫一般信号量，或者叫多值信号量，也叫计数信号量，就可以用于解决同步问题 

![_config.yml]({{ site.baseurl }}/images/88OS/image227.png)  

并发进程中间的一些关键活动，也就是涉及到了共享变量的代码语句。 找到了涉及共享变量的代码和语句后，就把它划定为临界区。针对多个进程的临界区，设置一个信号量 mutex。mutex 这个信号量，它的初值是 1 ，我们这里简单说明一下，这个mutex是大家常用于解决互斥问题的时候给信号量起的这样一个变量名，就是互斥mutual exclusive这两个词的前面几个字母拼出来的杜撰词，允许进临界区还是不允许进，在临界区的前面要实施 P 操作，P(mutex)，在出了临界区的时候，要实施 V 操作 V(mutex)，这就是用 P、 V 操作来解决进程间互斥问题的一个基本的步骤

例子：假设P1先上CPU，它在做 P 操作的时候，把 mutex 减1，mutex 现在是0，不小于0，所以P1进程可以进入临界区，如果P1进程在临界区的期间被中断了，P2进程正好上CPU，也想进临界区，它也要做 P(mutex)，而 mutex 刚才是0了，现在再减 1 就变成负 1 了。 根据定义，那么 P2 进程就等在 mutex 的这个队列上，让出 CPU 之后，假设 P3 进程又上 CPU 了，也要进临界区 又把 mutex 又减去了一次 1，就变成了负 2了，因此P3进程也等在这个信号量上，等在P2的后面，让出了 CPU。 假设 P1又上 CPU 了，然后它在临界区里头完成了它的工作，出临界区了。 出临界区它执行了一个 V(mutex)，mutex加 1 ，刚才是负 2，加 1 变成负 1，这个时候信号量的值还是小于等于 0，因此这个 V 操作就会到队列里头找到一个进程 P2 把它送到了就绪队列，然后 P1 接着做别的事情。 如果待会 P2 上 CPU 了，那么它就下一个就进入临界区了。 因为 P 操作已经执行完了，所以它接着就进临界区，当它出临界区又做一次 V 操作，mutex 就变成 0 了，变成 0 了之后还是小于等于 0 ，所以V 操作就会把队列里等的 P3 让它进入就绪，就是这样一个过程。 所以用 P、 V 操作解决临界区的这种互斥问题是非常简单的

![_config.yml]({{ site.baseurl }}/images/88OS/image228.png)  

# 7、生产者消费者问题  

生产者的行为是生产一个产品并且把这个产品送到缓冲区里。 消费者是从缓冲区里头取产品，并且把产品消费掉。 那么这里头我们知道生产者是不能够往满的缓冲区里头放东西的。 因此我们设置了一个信号量empty。 empty实际上是表示了在缓冲区当中有多少个空缓冲区。 它的初值肯定是n，刚开始的时候n个缓冲区都是空的。 

消费者不能够从一个空的缓冲区取东西。 因此设置了另外一个信号量 full。full 的初值是 0 ，也就是一上来消费者是取不到东西的，刚开始的时候在生产者没有生产产品的时候，那么buffer是空的。 full 实际上就代表了在buffer里头有哪些 buffer 是有内容的，是有产品有数据的。 当然我们还设置了一个信号量 mutex。 因为不允许同时生产者和消费者都往同一个缓冲区里放。 用一个 mutex 来保护这样一个 buffer。 

假如生产者一直在cpu上执行，那可以循环n次，也就是可以往buffer 里放n个数据。 当它把 buffer 放满之后，那么 empty 每次减一，减到0了。 第 n+1 次循环的时候，empty 值已经是零，P(&empty) 再去减一。 那么我们知道这个时候已经是负一了，负一那么生产者就被阻塞了，什么时候把它从阻塞态进入就绪态，那要看消费者。 消费者取走一个产品之后，就去对 empty 做一次 V 操作，取走一个就加一。 那么如果它被阻塞了，加完一之后就被释放了。 所以这边是 P 操作，这边是 V 操作，我们已经看到了在解决这个同步问题的时候， 对同一个信号量的 P 操作和 V 操作是分散在 两个不同的进程里头的，这就是同步。P(&full) V(&full)同理

buffer里的数据不允许同时又送又取，因此对它进行了一个互斥，意思就是说对 buffer 的操作实际上是一个互斥的。P(mutex) 操作 V(mutex) 操作实际上是保护这个 buffer 

![_config.yml]({{ site.baseurl }}/images/88OS/image229.png)  

两个P 操作的顺序是不是可以颠倒。假设它颠倒了， 把消费者的 P(&mutex) 先执行，再执行 P(&full)。 假如说这个时候 buffer 是空的， 那么消费者上来先执行的 P(&mutex) ，mutex 值等于0了，然后 接着执行 P(&full) ，而这个时候我们知道消费者就等在 full 这个信号量上了，因为 buffer 现在是空的。 而这时候如果让出了cpu，假设生产者来生产，那么生产者P(&empty)一看有空 buffer 可以生产。 它要接着往 buffer 里送的时候，要执行 P(&mutex)，可是 mutex 已经是0了，再去执行 P(&mutex) ，那么 mutex 等于负一， 所以按照 P 操作定义，那么生产者也要等待进入临界区。 一方面消费者等产品， 一方面生产者想放产品，但是进不了临界区，所以它们两个进程谁也不能往前执行。 这就是出现了死锁问题。

因为V操作只是把信号量的值加一。 然后看一看有没有进程等在队列里头，如果有就把它释放。V 操作不会使得调用 V 操作的这个进程进入等待状态，所以这两个的顺序是可以颠倒的。 但可能会带来其他的一些问题，比如说，如果我先做的是 V(&empty) 再去做 V(&mutex) 那么临界区里头就会多一点点指令。 那么其他的进程想进临界区可能会稍微晚一点进临界区。 不会出错但当前这样的顺序是最理想的，因为它把临界区界定在最小的范围内。那么消费一个产品consume_item能不能放在V前面，肯定没有错误，但也是把临界区的范围扩大了。临界区的范围扩大就在临界区待的更长的时间。 不需要在临界区里做的事情尽量不要在临界区里做。

![_config.yml]({{ site.baseurl }}/images/88OS/image230.png)  


# 8、读者写者问题   

![_config.yml]({{ site.baseurl }}/images/88OS/image231.png)

读者写者问题本质上是一个互斥的问题。

![_config.yml]({{ site.baseurl }}/images/88OS/image232.png)  

由于读操作和写操作实际上就是一个临界区，在进临界区之前要做一个P(w) 做完了读操作，去执行一个V(w)，在写之前做一个P(w)，写完了之后做一个V(w) 那么这就是一般的临界区的保护。

第一类读者写者问题实际上要解决的是多个读者可以同时读，不需要每个读者都去做P(w)或做V(w)，第一个读者他到来的时候，如果没有其他的读者和写者，他可以去读，他在读之前首先要把临界区保护起来，所以第一个读者是要做P(w)的，而后续的读者，只要前面有读者在读，那么后续来的读者都可以去读。 当所有的读者都读完了， 那么就会把临界区还回来，那么这样就是最后一个读者去做V(w)操作。

![_config.yml]({{ site.baseurl }}/images/88OS/image233.png)  

我们应该让第一个读者去做P(w)，让最后一个读者做V(w)，把代码改成这样一个版本，在读者里头引入了一个计数器，rc记录了现在有几个读者。 来了一个读者rc ＋ 1 判断一下他是不是第一个读者，如果rc=1，表示他是第一个读者，他就去做P(w)的工作，当最后一个读者走的时候，因为每个读者离开都要去rc- 1，当最后一个读者做完rc- 1， rc就等于0了，所以最后一个读者就要去做V(w)操作，但是会引出新的问题。 因为我们是多个读者，所以多个读者都对rc进行相应的操作，所以rc就成为了一个新的临界资源，那么rc=rc+1判断rc，或者rc=rc-1判断rc 都是一个临界区。 因此我们还要针对这样一个临界区，再增加一个互斥的信号量。 因此我们要对rc进行保护，这就是第一类读者写者问题的一个解决方案。

![_config.yml]({{ site.baseurl }}/images/88OS/image234.png)  

看一个例子，路由器经常在网络上需要查路由表，比如说选择一个，我要发一个包到网络的另外一端，那么我需要通过路由表来选择我的路径，那我要去读这个路由表，所以读的工作是非常多的，如果一旦我的这个网络拓扑发生了改变， 那么就要去重新修改路由表，要添加一些路径或者是删除一些路径 因此，改路由表的工作也会有，但是呢不常发生。 Linux实际上就提供了一个读写锁，如果我们用读写锁，也就是读者写者问题的解决方案来对路由表进行相应的操作，读路由表的时候我们就用读锁，写路由表的时候我们就用写锁 ，由于读的时间多，更多地发生，因此用不同的锁来对路由表进行保护，提高了一个读写操作的性能，Linux实际上提供了这样一个读写锁对路由器的路由表的操作过程中来并发访问。

![_config.yml]({{ site.baseurl }}/images/88OS/image235.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image236.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image237.png)  