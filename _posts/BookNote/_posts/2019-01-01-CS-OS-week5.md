---
layout: post
title: week5 同步机制(1)
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、进程的并发执行  

![_config.yml]({{ site.baseurl }}/images/88OS/image200.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image201.png)  

并发指的是进程的执行是一种间断性的,也就是每个进程在它的生命周期期间一会儿上 CPU 执行，一会儿由于某种原因暂停执行,由于这种间断性使得进程的相对执行速度是不可预测的,由于有进程调度，有其他事件的发生，每个进程上 CPU 可能执行一段时间停止，然后再接着执行，所以整个执行的时间是不可预测的   

在一个并发环境下多个进程或者线程之间会共享某些资源，那么在这些资源的使用过程中，它会产生进程之间的一种制约性 比如说当一个进程享用打印机这个资源 那么另外一个进程在第一个进程没有释放这个资源的前提之下，那么就得不到这个资源，那就得等待。因此在一个并发环境下，多个进程的执行会带来一种制约。

进程的执行结果和它的相对执行速度是有关系的，因此 在不同的执行顺序的情况下，那么进程的执行结果也是不确定的   

![_config.yml]({{ site.baseurl }}/images/88OS/image202.png)  

在写回去的时候不管是 T1 先写回去，还是 T2 先写回去，如果我们没有对这个账户加以控制使得 T1、 T2 这两个程序当中的一些关键活动 出现了交叉，那么就可能会出现与时间有关的错误。   

比如说 T1 先把 x 的值减完 1000 之后，再把它写回到账户上 那么这个时候账户上应该是 4000 元，可是 T2 因为刚才已经把 5000 元读到了 x，所以对 x 减去 2000 之后，那么再把它写回去的时候，就是相当于把 3000 元写回去 那么当然如果反过来，T2 先写 回去，T1 再写，那么账户上的余额呢就变成 4000 元，由于这两个进程它们的关键活动 中间出现了交叉，因此账户上的余额是不对的

![_config.yml]({{ site.baseurl }}/images/88OS/image203.png)  

f 缓冲区和 g 缓冲区可以分别存放多个数据，而 s 和 t 缓冲区呢只能放一个数据。  

这三个进程呢都是循环执行的 第一个进程get 的工作是把 f 里头的数据取一个送到 s 里，copy 是从 s 里取一个数据送到 t 里 而 put 是从 t 里头取一个数据往 g 里去送。假设 get 可以循环很多次 当它第一个把数据读到了 s 里头以后，那么再读第二次的时候 由于 s 里的数据假设还没有被 copy 给取走，那么第二次往 s 里送的数据实际上就把前面送的数据给覆盖掉了。为什么会出现这种情况？因为我们这是一个在一个并发环境下执行的，任何一个进程都可能会被调度上 CPU，那么也可能会出现 put 先被调度上 CPU，而 t 里的内容还没有准备好，那么就可能说把一个不需要的数据送到了这个 g 缓冲区，所以这是可能会出现各种各样的情况。

![_config.yml]({{ site.baseurl }}/images/88OS/image204.png)  

我们假设 g,c,p 分别为 get,copy 和 put 的一次循环，因此从当前状态出发，我们可能有这样一种组合的执行过程。 那么 get, copy put 各执行一个循环，那么得到的结果就是把 3 这个数据运到了送到了g 里头去，这是一个正确的结果，因为 s 和 t 里头分别也放了是 3 这个数据，但是如果还从这样一个当前状态出发，如果是 g,p,c 这样一个执行的轨迹，我们会看到最后 g 这个缓冲区里头得到的是 1,2,2 ，前面的几个缓冲区数据是对的，但是这个结果就是错的，这是一种错误的情况

在一个并发环境下 三个并发的进程在执行过程中由于调度，其他的因素会造成错误

![_config.yml]({{ site.baseurl }}/images/88OS/image205.png)  

这三个进程它们之间是有制约关系的 而没有满足这种制约关系就会出现刚才的错误。现在我们来看一看这三个进程的制约关系是什么样子的

这三个进程的制约关系是什么样子的，用一个进程的前趋图来表示，那么 g1 代表的是get执行第一个循环，c1表示的是 copy 执行的第一个循环。 那么我们可以看到当 get 执行完第一个循环之后，只能够 copy 执行它的第一个循环。 当 copy 执行完第一个循环之后，那么后面是 put 执行第一个循环，还是 get 执行第二个循环，都可以，这两个可以顺序可以颠倒，可以任意的顺序。 但是它们两都执行完了，才能够去执行 copy 的第二个循环。因此这三个进程它们之间的这种制约关系应该满足这样一个前趋图，这样才能保证不出错误

![_config.yml]({{ site.baseurl }}/images/88OS/image206.png)  

# 2、进程互斥

引入“竞争条件”概念，这张图反映了一个 Spooling 技术用于打印机，其需要维护一个打印的目录Spooler，有一个打印机的守护进程随时看管这个目录，这里头存放了所有的进程，需要打印的这种文件的文件名。当这个缓冲区里头有文件名的时候，打印进程就工作，没有文件名的时候，打印机可以去睡眠。 

对于这样一个目录，需要用一个 in 这个变量来表示当前哪一个缓冲区的槽是空的，那么进程可以把要打印的文件名送入到这个槽中。假设有这么一个情况，进程 A 和进程 B 都需要打印了，假如说进程 A 它先从 in 这个变量里读到了当前的这个，可以存放文件名的索引，比如说是 7 ，那么把它这个值读入到自己的这个局部变量里头，然后它就去把文件名送到了这个7对应单元，那么这个时候它应该把7更新到8，可是在这个更新之前，进程A被切换下 CPU，它还没有把 in 更新成更新为 8 ，它下 CPU 之后 假如说进程 B 要上 CPU，它也要打印，从 in 里头得到了一个 7 这个值 因此，进程 B 就会把它要打印的文件名也送到 7 对应的单元，把刚才进程 A 送的那个文件名就覆盖掉了，进程 B 把 in 改成 8 之后，去做别的事情去了，因此进程 A 就再也得不到自己的打印的结果了 

竞争条件的定义是：就是说两个或多个进程在读写某些共享数据的时候，这个 in 就是共享数据 而最后的结果取决于进程运行的一个精确的时序，就是时间序列，就是它跟时间是相关的 这就是带来了竞争条件。所以竞争条件是由于有这样一个共享的资源，共享的数据，而多个进程都对这个数据进行相应的操作带来的  

![_config.yml]({{ site.baseurl }}/images/88OS/image207.png)  

进程互斥：由于在一个并发环境里头多个进程都要使用一些共享资源，像一些变量啊、文件，这些资源具有这样一个性质，它需要排他性的使用，也就是说我用那么另外一个进程就不能用，因此，各个进程之间对这个资源的使用是一种竞争，这种竞争称之为进程的互斥。

当一个进程用，另外一个进程用不了，那么这个共享资源给它起了一个名字叫做临界资源，有的时候也叫互斥资源 它的特点是一次只能给一个进程使用，那么当多个进程都要使用同一个共享资源的时候，它的代码里头会有相应的操作，这些代码叫做临界区，也叫互斥区，所谓临界区和互斥区是多个进程当中，对某一个共享变量，或者临界资源实施操作的**程序片段**，这些程序片段分散在不同的进程里头，那么它们的共同的特点，是对同一个共享变量进行一些操作，那么这一段代码和另外一个进程的这一段代码，他们互为临界区，互为互斥区

![_config.yml]({{ site.baseurl }}/images/88OS/image208.png)  

有了互斥区之后，我们会看到在互斥区的使用上，是要满足一定的条件的。比如说，当 A 进程进入临界区，在临界区里头，还没有出临界区的时候，如果B进程上CPU之后也想进临界区，应该不能够让B进去，因为如果B进程也进临界区，就会出现关键活动的交叉，就会出现前面我们所介绍的各种各样带来的错误 因此，当 B 进程想要进临界区的时候，由于 A 进程还在临界区里头没有出来，所以 B 进程只能够被阻塞，不能进临界区。上一讲我们所介绍的优先级反转问题，一个低优先级的进程进到了临界区，那么这个时候因为它优先级比较低，那么有更高优先级的进程就绪的时候，就会抢占它的CPU ，但更高优先级的进程需要进入临界区，可是低优先级的进程在临界区里头，它进不了这个临界区，也就上不了CPU 运行，所以就被阻塞。而在高优先级和低优先级 之间，又源源不断的会有一些中级优先级的，但是又非常耗时的这样的一些进程在执行，使得低优先级的进程上不了 CPU ，也就不能够让高优先级的进程尽快上 CPU ，因为它被阻塞    

等到 A 进程离开临界区 B 进程才能够进入它的那段代码

![_config.yml]({{ site.baseurl }}/images/88OS/image209.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image210.png)  

# 3、进程互斥的软件解决方案   

free来代表临界区是否空闲,如果free等于true，就表示说有进程在临界区，如果free等于false ，就表示说临界区是空闲的。现在有两个进程当它们都想进临界区的时候，首先要做的事情是要判断一下 free 这个标志，如果 free 这个标志是 false，那么这个循环while(free)就结束，进到下面一条语句，也就是把这个标志设置为true，表示有进程在临界区，假设 P 先上的 CPU，因为 free 的初值是 false ，所以这个循环就结束了,如果这个时候进程 P 被切换下 CPU ，P 还没有来得及改变free的值,正好下面上 CPU 的进程 Q 它也要判断 free 的这个标志是不是 false ，由于进程 P 还没有来得及改变它的值，因此检测的结果是 free 也等于 false ，所以它继续往下走把 free 变成 true ，然后进入了临界区。如果 Q 进入临界区之后又一次被切换下去了，在这个时候P 上 CPU 了，把 free 变成 true ，然后进入临界区，那么两个进程都在临界区，这是一个错误的解法    

可以把图中两条语句写成一个 lock 函数，如果把 lock 函数的这个执行设计成一个原语，也就是在执行过程中不容许被中断，那么这个操作就是正确的了。同样free 等于 false ，也把它封装成一个解锁的函数，也是一个原语操作，虽然是一条语句，但这条语句变成了指令一级的话，会变成多条指令。 所以，同样我们需要把 unlock 这个函数啊，设计成一个原语

![_config.yml]({{ site.baseurl }}/images/88OS/image211.png) 

设置了一个turn标志，如果等于 true 表示 让 P 进程进临界区，如果 turn 等于 false 就让 Q 进程进临界区。初值是任意，那么可能会出现这样一个场景，就是说 P 进程想进临界区，由于 turn 等于 false ，所以进不去， 所以 P 进程老在那等待进入临界区，它在那循环。 可是如果 Q 进程始终没有进过临界区，也不想进临界区，那么 P 进程就进不了临界区，尽管临界区里头没有进程 也就是说，在临界区外的进程 Q 阻止了 P 进程进临界区，这是不容许的，这也是违反我们前面所介绍的使用临界区的原则   

![_config.yml]({{ site.baseurl }}/images/88OS/image212.png)   

进临界区它的条件判断是，P进程要想进临界区，首先 pturn等于true ，然后qturn 呢不等于 true，这样P进程可以进临界区，同样Q进程也是要判断自己想进临界区并且对方不想进临界区的时候。如果P进程上CPU了，那么pturn等于true ，假设 P 进程又被切换下去了，当Q 进程上CPU，也想进临界区，qturn等于 true ，接着Q 进程会去判断能不能进，可是刚才由于P进程已经设置 pturn 等于 true 了，所以Q进程就会在这不断的循环，时间片到了Q 进程被切换下CPU，假设 P 进程又上 CPU 了，要判断 Q 进程想不想进临界区，Q进程是想进临界区的，所以P进程也不进临界区，临界区是没有进程在里头的，而P进程和Q进程也都不进临界区，两个进程不断的在这循环，谁都不去进临界区。这么一个场景称为 after you 问题，就大家都在谦让，谁也不进临界区，这也不满足临界区的使用原则

![_config.yml]({{ site.baseurl }}/images/88OS/image213.png)  

刚才算法3的基础之上，又引入了一个turn变量，这个turn变量是相当于是一个枚举类型，在两个进程都想进又都谦让的这种情况下，由 turn 来决定谁进   

这两条语句while(turn==)就是说在在让出CPU之后还要保持不断的循环去判断是不是该轮到自己了，因此这里有一个循环直到它把它的时间片用完,然后被切换下 CPU，始终在 CPU 上在循环,我们称之为叫忙等待 busy waiting

一个CPU时，没有其他进程上CPU，则必须在CPU用完了时间片才能被切换下去，所以浪费了这些时间，这就是 DEKKER 算法

![_config.yml]({{ site.baseurl }}/images/88OS/image214.png)  

PETERSON 算法解决了互斥访问问题，同时克服了DEKKER 算法强制轮流的缺点，方案对于开发的用户非常容易使用的。  
 
任何一个进程当它想进临界区的时候，它只需要调用一个 enter_region函数 来看一看能不能安全地进入临界区，如果能安全地进入临界区，那么就是相当于这个函数执行结束，它就可以进临界区了。如果不能够安全地进入临界区，那么它就在这个函数当中去等待进入临界区。 当进程使用完临界区的相关资源之后，出临界区的时候调用一个 leave_region，那么也就是可以让其他的进程进入临界区。 

enter_region函数设计：  

这个代码当中interested 是一个数组，它是表示出哪个进程想进临界区，要把这个意愿表达写在这个数组的某个单元里头，假设我们有两个进程，进程号是0和1，另外一个进程的编号other就是1减去当前这个进程的进程号 然后在这个数组里头表达进程想进临界区，把这个单元设置成true，在此之后有一个非常重要的变量turn，当前的这个进程进程号赋给这个 turn ，那么谁要想进临界区，就用自己的进程号赋给这个turn，如果两个进程同时想进临界区，大家都可以往里头赋值，比如说 0 和 1 都想进临界区，那就看谁先赋值给 turn，谁后赋值给 turn ，我们假设 0 号进程先赋值给 turn 那么后，后面的是 1 号进程赋值给 turn，先赋值给 turn 的那个值实际上就被后面赋值的这个覆盖掉了，所以 turn 里头始终保持是后面要想进临界区的进程的进程号

两个进程都想进，希望谁先来的谁先进，也就是谁先给 turn 赋值，谁先进临界区。 这有一个判断，turn 等不等于 process，process是当前这个进程的进程号，如果你是要先进临界区，假设turn 的值后面已经被后面那个进程给覆盖掉了，现在 turn 不等于 0 了，这个条件不成立，循环就结束了，换句话说，0号进程循环一次都没有做就出来了进临界区，1 号进程是后把这个进程号赋给这个 turn 的，所以turn 的值就等于 1 ，两个条件都成立，所以进程 1 调用了enter_region，实际上是在做循环。

![_config.yml]({{ site.baseurl }}/images/88OS/image215.png)  

# 4、进程互斥的硬件解决方案

![_config.yml]({{ site.baseurl }}/images/88OS/image216.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image217.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image218.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image219.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image220.png)  

# 5、

# 6、

# 7、

# 8、