---
layout: post
title: week4 处理器调度
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、处理器调度的相关概念   

![_config.yml]({{ site.baseurl }}/images/88OS/image145.png)  

**CPU调度相关概念**  

![_config.yml]({{ site.baseurl }}/images/88OS/image146.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image147.png)  

系统运行时，会发生很多的事件，比如说，I/O 中断，时间中断。 这些事件发生以后，系统要做相应的处理。事件的发生使得当前正在运行的进程暂停，硬件机制响应这个事件，进入了操作系统，操作系统处理相应的事件，当事件处理完后，某些进程的状态发生了变化，也可能又创建出了一些新的进程，这就导致了就绪队列改变，这就需要进程调度，按照事先预定的算法 从就绪队列中重新选择一个进程，这就是调度的时机。 也就是就绪队列的改变引发了重新调度   

![_config.yml]({{ site.baseurl }}/images/88OS/image148.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image149.png)  

什么时候重新调度？往往是内核对中断、陷入、系统调用等处理之后返回到用户态的时候，这个时候要重新调度，这就是CPU调度的时机   

![_config.yml]({{ site.baseurl }}/images/88OS/image150.png)  

因为新的进程上CPU ，那么它要用自己的地址空间，所以要切换全局页目录，目的是加载一个新的地址空间。

![_config.yml]({{ site.baseurl }}/images/88OS/image151.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image152.png)  

高速缓存里头存放了一些刚才执行的进程当中的一些指令和数据，TLB 快表里头存放了这个进程的一些页表表项，新的进程上 CPU 之后，原来的这些内容都没用了，要把新的进程所需要的指令数据，送入高速缓存 或者是把新的进程的页表表项，送入TLB快表里，这需要花一些时间(间接开销)   

![_config.yml]({{ site.baseurl }}/images/88OS/image153.png)  

早期的批处理对调度算法的要求不高，因为它是一个程序执行完了以后接着执行下一个程序，但是当有了多道程序设计系统之后，那么多个程序都要想进内存，都上 CPU，那么调度算法就要去选择让哪些进程早一点上 CPU ，到了批处理与分时系统，一个混合系统的过程中，调度算法既要照顾到前台的进程，也要照顾到后台的进程，需要合理地来安排调度的顺序，让不同的进程都能有机会上 CPU 执行，个人计算机刚开始的时候调度算法非常简单 后来慢慢演化到现在，桌面操作系统里头调度算法变得非常复杂 对于网络服务器由于有多个客户端同时向它提出服务请求，所以要在调度算法上下一些功夫，要斟酌不同的调度算法。设计调度算法的时候，从用户的角度和系统的角度对调度算法的要求是不一样的

用户对性能的要求，周转时间短一点，响应时间快一点，如果有些紧急的任务应该能够在最后的期限之内能够完成。 从系统的角度，它可能追求的是吞吐量，追求的是 CPU 的利用率和资源的利用率，在其他方面，从用户的角度，希望能够对自己的程序什么时候运行有一个可预测，从系统来看，更多的考虑是不是对所有的进程都是公平处理的， 如果有一些进程更重要，更紧急一些，是不是能够让它尽快地执行，另外系统中各种资源是不是都能够平衡地使用。用户的角度和系统的角度对于调度算法有不同的要求。 而这些要求有的时候往往是相互矛盾的。 因此，在设计调度算法的时候要在各种因素当中折中权衡   

![_config.yml]({{ site.baseurl }}/images/88OS/image154.png)  

资源的利用率也就是CPU有多长时间是空闲的，有多长时间是忙碌的。  

![_config.yml]({{ site.baseurl }}/images/88OS/image155.png)  

# 2、设计调度算法要考虑的几个问题  

![_config.yml]({{ site.baseurl }}/images/88OS/image156.png)  

优先级表现出了进程的重要性和紧迫性。优先数呢实际上是一个数值，它反映了某一个优先级。 UNIX 优先数小的优先级高， 所以不能完全根据数的大小来决定优先级的高低

![_config.yml]({{ site.baseurl }}/images/88OS/image157.png)  

有了优先级以后，可以按照优先级来重新组织就绪队列 当创建一个新的进程的时候，那么根据它的优先级排入不同的就绪队列，图中设定了n个就绪队列优先级，不同的优先级进程进入不同的就绪队列 ，那么就绪队列 1 的优先级是最高的，当调度程序选择进程的时，首先应该从高优先级的队列来选择进程，如果高优先级队列没有进程了，再从次高就绪队列来选择进程 

![_config.yml]({{ site.baseurl }}/images/88OS/image158.png)  

另外一种排队的方式，所有的进程第一次创建之后，都进到第一级就绪队列，随着进程的运行，我们可能会降低某些进程的优先级，比如说当一个进程分配给它的时间片用完了，那么它就会降一级，降到第二级就绪队列。 如果它经常地用完时间片，慢慢这个进程就会降低到最后一级就绪队列，进程调度首先在第一级队列里选 那就说明第一级就绪队列的优先级比较高，如果这个队列是空的，调度就会从其他的就绪队列里头选择进程，如果你的进程已经进到了最后一级队列，那么它的优先级就越来越低 它被调度上 CPU 的机会就会变得很小  

![_config.yml]({{ site.baseurl }}/images/88OS/image159.png)  

占用 CPU 的方式：   

抢占则CPU上运行的永远是优先级最高的进程。 

不抢占则正在运行的进程可能比某个在就绪队列中的进程的优先级略微低一点，因为那个进程是在这个进程上CPU之后才进入就绪队列的

![_config.yml]({{ site.baseurl }}/images/88OS/image160.png)  

可以看到 I/O型的进程占用CPU的时间都比较小，在设计调度算法的时候，通常对 I/O 型的进程会比较友好，希望更多的 I/O 型进程早一点上 CPU 运行，因为这些进程上CPU 之后，只用了很短的一下 CPU 时间就会让出 CPU，因为它要去做其它的输入输出操作了。因此对于一般的这个调度程序，都会对 I/O 型进程更偏好一些

![_config.yml]({{ site.baseurl }}/images/88OS/image161.png) 

时间片指的是一个时间段分配给上CPU的进程，允许这个进程在 CPU 上执行多长时间，它是一个时间的长度，选择时间片考虑的因素有，比如说 进程切换它的开销有多大，进程对响应时间的一个要求，系统当中有多少进程处于就绪 CPU 的能力有多大，以及进程的行为，不同进程我可能区别对待。 因此 在设计时间片大小的时候要考虑到这些因素。到底时间片长一点好，还是短一点好？ 每个进程分配的时间片都是固定的，还是可以变化的？  

![_config.yml]({{ site.baseurl }}/images/88OS/image162.png) 

# 3、批处理系统的调度算法  

在批处理操作系统当中，对于算法的要求往往是看它的带来的吞吐量是不是大，周转时间和 CPU 利用率这几个因素。 当然也要考虑到公平和平衡的问题。

![_config.yml]({{ site.baseurl }}/images/88OS/image163.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image164.png) 

选择进程的时候从队首选择，新就绪的进程排在队尾

![_config.yml]({{ site.baseurl }}/images/88OS/image165.png) 

改变调度的顺序，也就是调度算法的改变会改善平均周转时间， 进而可能改善了响应时间这些指标

![_config.yml]({{ site.baseurl }}/images/88OS/image166.png) 

把短作业优先调度算法改进加了抢占，那就是最短剩余时间优先调度算法。 所谓最短剩余时间就是，当一个新就绪的进程比正在当前运行的进程的剩余的运行时间短的时候， 系统就会去抢占当前的进程，然后把 CPU 交给这个运行时间更短的进程。 因为在一个短作业运行的过程中，可能有一个新的进程 创建出来，或者是一个进程从等待变成就绪，那么它 剩余的时间比当前正在运行的这个进程剩余的这个运行时间还短， 就要抢占了。 不管是短作业优先还最短剩余时间优先这样的调度算法， 它的主要思想就是首先先把短的作业完成，这样就可以改善短作业的一个周转时间。

![_config.yml]({{ site.baseurl }}/images/88OS/image167.png) 

零时刻P1进程到达，被调度上 CPU ，因为没有其他的进程存在。 在它运行的 7 个单位期间， 那么剩下三个进程都已经到位了。 当 P1 运行完成， 那么系统就要在这三个进程中去挑选， 哪个进程运行的时间短，哪个进程上 CPU。 P3 运行一个单位，所以P3 上 CPU。 然后在 P2 和 P4 中去选，那它俩是一样，那么先选谁先来的，因此P2 上 CPU。 然后P4 上 CPU。如果我们用抢占式的最短剩余时间优先调度算法， P1 上 CPU，在它运行完 2个单位之后，P2 到达。 P2 需要运行 4 个单位， 而 P1 还剩余 5 个单位，所以换进程了，P2 上 CPU。 当 P2 也运行完 2 个单位之后，这个时候 P3 到达了，再去重新调度， P3 还剩下 1 个单位，P2 剩 2 个单位， P1 剩 5 个单位，所以P3 上 CPU 运行，它运行完一个单位之后，这个时候系统中有 P1、 P2 和 P4， P4 需要 4 个单位，P2 剩下 2 个单位， 而 P1 剩下 5 个单位，所以又选择了 P2。 然后 P4 ，最后 P1 接着执行之后的 5 个单位。  

![_config.yml]({{ site.baseurl }}/images/88OS/image168.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image169.png)   

操作系统当中的一个常用的手段，就是折衷权衡。既保持先来先服务的优点，克服其缺点，又能够保持短作业优先的优点，克服其缺点。 这个调度算法其中一个叫最高响应比优先。 它是一个综合的算法。 它的基本思想是这样的： 在调度的时候，首先先计算每个进程的一个数值响应比，一个参数， 也可以看成是一个权值。 那么计算完之后，在所有的进程当中选择响应比最高的进程执行。计算公式可以有不同的设计。

![_config.yml]({{ site.baseurl }}/images/88OS/image170.png) 

# 4、交互式系统的调度算法   

追求的指标主要是响应时间,公平啊，资源的平衡使用  

![_config.yml]({{ site.baseurl }}/images/88OS/image171.png)   

当前正在运行的是B进程,排在它后面的是一个F进程,当B进程用完它的时间片之后，它就回到了队列的末位，然后调度选择下一个进程，现在是当前运行进程F上CPU,这就是一个时间片轮转，然后F运行完它的时间片它就继续去排队,这个队列里面的每一个进程都有机会轮流上 CPU。时间片轮转调度算法的主要目标就是改善短作业或者短任务的平均响应时间。具体的做法就是通过周期性地切换，然后每个进程分配一个时间片，通过时钟中断引发轮换，来达到改善短作业平均响应时间，这是时间片轮转算法。  

![_config.yml]({{ site.baseurl }}/images/88OS/image172.png)   

时间片如果太长，大于典型的交互时间，进程运行运行没有用完时间片就已经完成了它的交互，已经完成了一个响应，如果系统中所有的进程或者绝大部分进程，都不到一个时间片就可以完成响应，那么时间片轮转算法实际上已经退化成了先来先服务的这种算法，另外如果时间片过长 如果系统中有比如说 50 个进程，那么每个进程我时间片比如说是 100 毫秒 那么最后一个进程要等5秒钟才能轮到它上 CPU，因此会延长某些进程的响应时间，响应时间变长了

时间片如果太短，如果短得小于典型的一个交互时间，大部分进程一个时间片都完成不了，某个进程给的时间片很短，那么在中途会切换其他进程上 CPU，这个进程的响应时间就会变长，因为它会频繁地去切换，切换本身会带来开销，是要花时间的 所以，切换带来的开销呢也就浪费了 CPU 的时间。那么典型的时间片的大小有一些经验值，那么大概在 10 毫秒到 100 毫秒之间，通常可能是五六十毫秒这个样子 

![_config.yml]({{ site.baseurl }}/images/88OS/image173.png) 

它是公平的，因为轮流上CPU，都有机会上 CPU，都分配给同样的时间片

![_config.yml]({{ site.baseurl }}/images/88OS/image174.png)  

有两个进程 A 和 B，它们都分别要运行 100 毫秒，那么如果时间片大小给的是 1 毫秒 ，假设上下文切换没有耗费时间，采用时间片轮转算法算一下它的平均完成时间。最后 A 进程运行完已经是 199 毫秒，B进程运行完是200毫秒的时候了 所以它们的平均的完成时间是在 199.5 毫秒   

采用先来先服务调度算法， A 执行完 100 毫秒， B进程执行，它先等了 A 执行 100 毫秒，等了 100 毫秒，然后再执行自己的 100 毫秒，所以两个进程花300毫秒执行完，平均完成时间 150 毫秒   

![_config.yml]({{ site.baseurl }}/images/88OS/image175.png) 

时间片轮转算法不区分 I/O 型进程还是 CPU 型进程，这会给 I/O 型进程带来一定的不公平。当一个 CPU 型进程被调度上 CPU 之后 它用完了它的时间片，然后重新排队，下一次再调度上 CPU 又用完一个完整时间片。I/O 型进程被调度上 CPU 之后 它没有运行完它的时间片，可能运行的很短，然后就去等待 I/O，因此它就放弃了 CPU ，进入了等待队列 那么一旦等待的结果到来，它就又变成一个就绪进了就绪队列，再次上 CPU ，它又没有用完分配给它的时间片，那么感觉 CPU 型的进程总是用完给它的时间片。 所以它占用了更多的 CPU 时间，而 I/O 型进程总是用不完它的时间片，所以这个调度算法对它有些不公平，它用的总是很少，然后又去重新排队  

当一个 I/O 型进程，让出CPU进到等待队列，从等待队列又重新回到就绪状态的时候，不去进入原来的就绪队列，单独为它设置一个队列，叫做辅助队列 也就是所有 I/O 型的进程，从等待变成就绪的时候进到这个队列，那么调度算法在选择进程的时候，首先先从这个辅助队列里去选择进程，那么 I/O 型进程上 CPU 之后，又很快地放弃了 CPU ，进入等待。直到辅助队列为空才去从就绪队列里头去选进程，这种设计方案改善了对 I/O 型进程的一种不公平性    

![_config.yml]({{ site.baseurl }}/images/88OS/image176.png) 

系统进程的优先级往往高于用户进程，前台进程的优先级往往高于后台进程，操作系统的调度算法来讲，比起CPU 型进程更偏好 I/O 型进程 

![_config.yml]({{ site.baseurl }}/images/88OS/image177.png) 

基于优先级的调度算法会产生的一个新的问题，优先级翻转问题。 这个问题主要是抢占式的优先级调度算法产生的，优先级翻转问题有的时候也称之为优先级的反置，是倒挂。它的现象是有一个低优先级的进程占有了一个高优先级进程所需要的资源，那高优先级的进程就不能运行。 因为它受制于这个低优先级的进程 就产生了优先级翻转。我们举一个场景，如果一个系统中，有高优先级的进程 H ，有低优先级进程 L ，一个中间的优先级进程 M，这个进程恰好是一个 CPU 型进程,它要用很长的 CPU 时间。如果在某种情况下低优先级的进程被调度上 CPU 了，那么它在进入临界区执行的过程当中，没有出临界区就被抢占了，它就变成就绪，这个时候高优先级的进程也要进临界区但进不去只能被阻塞，等待低优先级的进程出临界区之后，把资源还给还给它。 可这时候在低优先级进程的上面又有一个中优先级的进程，这个中优先级的又是一个 CPU 型进程，所以它老占用 CPU 使得低优先级进程得不到机会去运行 那么低优先级进程不能运行，高优先级进程也无法运行 这就产生了一个叫做优先级翻转现象  

![_config.yml]({{ site.baseurl }}/images/88OS/image178.png) 

优先级翻转实际上是系统产生的一个错误 

有三种解决方案：

设置优先级的上限，凡是进入临界区的进程，给它的优先级都是最高的。不在临界区的进程，优先级都会比这个进入临界区的进程优先级要低，这样它就可以执行完成，然后把临界区还回去

优先级的继承，如果一个低优先级的进程阻碍了一个高优先级进程执行，它可以临时地继承这个高优先级的优先级，那么它就可以去运行，然后把临界区还回去   

禁止中断 凡是进入临界区的进程，那么就不再响应中断的。 直到它出临界区才响应中断，这样的话呢就保护了这个进程，让它继续去执行。

![_config.yml]({{ site.baseurl }}/images/88OS/image179.png) 


# 5、 多级反馈队列调度算法、各种调度算法小结等     

![_config.yml]({{ site.baseurl }}/images/88OS/image180.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image181.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image182.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image183.png) 
![_config.yml]({{ site.baseurl }}/images/88OS/image184.png) 
![_config.yml]({{ site.baseurl }}/images/88OS/image185.png) 
![_config.yml]({{ site.baseurl }}/images/88OS/image186.png) 
![_config.yml]({{ site.baseurl }}/images/88OS/image187.png) 
![_config.yml]({{ site.baseurl }}/images/88OS/image188.png) 
![_config.yml]({{ site.baseurl }}/images/88OS/image189.png) 

# 6、 

  