---
layout: post
title: week4 处理器调度
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、处理器调度的相关概念   

![_config.yml]({{ site.baseurl }}/images/88OS/image145.png)  

**CPU调度相关概念**  

![_config.yml]({{ site.baseurl }}/images/88OS/image146.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image147.png)  

系统运行时，会发生很多的事件，比如说，I/O 中断，时间中断。 这些事件发生以后，系统要做相应的处理。事件的发生使得当前正在运行的进程暂停，硬件机制响应这个事件，进入了操作系统，操作系统处理相应的事件，当事件处理完后，某些进程的状态发生了变化，也可能又创建出了一些新的进程，这就导致了就绪队列改变，这就需要进程调度，按照事先预定的算法 从就绪队列中重新选择一个进程，这就是调度的时机。 也就是就绪队列的改变引发了重新调度   

![_config.yml]({{ site.baseurl }}/images/88OS/image148.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image149.png)  

什么时候重新调度？往往是内核对中断、陷入、系统调用等处理之后返回到用户态的时候，这个时候要重新调度，这就是CPU调度的时机   

![_config.yml]({{ site.baseurl }}/images/88OS/image150.png)  

因为新的进程上CPU ，那么它要用自己的地址空间，所以要切换全局页目录，目的是加载一个新的地址空间。

![_config.yml]({{ site.baseurl }}/images/88OS/image151.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image152.png)  

高速缓存里头存放了一些刚才执行的进程当中的一些指令和数据，TLB 快表里头存放了这个进程的一些页表表项，新的进程上 CPU 之后，原来的这些内容都没用了，要把新的进程所需要的指令数据，送入高速缓存 或者是把新的进程的页表表项，送入TLB快表里，这需要花一些时间(间接开销)   

![_config.yml]({{ site.baseurl }}/images/88OS/image153.png)  

早期的批处理对调度算法的要求不高，因为它是一个程序执行完了以后接着执行下一个程序，但是当有了多道程序设计系统之后，那么多个程序都要想进内存，都上 CPU，那么调度算法就要去选择让哪些进程早一点上 CPU ，到了批处理与分时系统，一个混合系统的过程中，调度算法既要照顾到前台的进程，也要照顾到后台的进程，需要合理地来安排调度的顺序，让不同的进程都能有机会上 CPU 执行，个人计算机刚开始的时候调度算法非常简单 后来慢慢演化到现在，桌面操作系统里头调度算法变得非常复杂 对于网络服务器由于有多个客户端同时向它提出服务请求，所以要在调度算法上下一些功夫，要斟酌不同的调度算法。设计调度算法的时候，从用户的角度和系统的角度对调度算法的要求是不一样的

用户对性能的要求，周转时间短一点，响应时间快一点，如果有些紧急的任务应该能够在最后的期限之内能够完成。 从系统的角度，它可能追求的是吞吐量，追求的是 CPU 的利用率和资源的利用率，在其他方面，从用户的角度，希望能够对自己的程序什么时候运行有一个可预测，从系统来看，更多的考虑是不是对所有的进程都是公平处理的， 如果有一些进程更重要，更紧急一些，是不是能够让它尽快地执行，另外系统中各种资源是不是都能够平衡地使用。用户的角度和系统的角度对于调度算法有不同的要求。 而这些要求有的时候往往是相互矛盾的。 因此，在设计调度算法的时候要在各种因素当中折中权衡   

![_config.yml]({{ site.baseurl }}/images/88OS/image154.png)  

资源的利用率也就是CPU有多长时间是空闲的，有多长时间是忙碌的。  

![_config.yml]({{ site.baseurl }}/images/88OS/image155.png)  

# 2、设计调度算法要考虑的几个问题  

![_config.yml]({{ site.baseurl }}/images/88OS/image156.png)  

优先级表现出了进程的重要性和紧迫性。优先数呢实际上是一个数值，它反映了某一个优先级。 UNIX 优先数小的优先级高， 所以不能完全根据数的大小来决定优先级的高低

![_config.yml]({{ site.baseurl }}/images/88OS/image157.png)  

有了优先级以后，可以按照优先级来重新组织就绪队列 当创建一个新的进程的时候，那么根据它的优先级排入不同的就绪队列，图中设定了n个就绪队列优先级，不同的优先级进程进入不同的就绪队列 ，那么就绪队列 1 的优先级是最高的，当调度程序选择进程的时，首先应该从高优先级的队列来选择进程，如果高优先级队列没有进程了，再从次高就绪队列来选择进程 

![_config.yml]({{ site.baseurl }}/images/88OS/image158.png)  

另外一种排队的方式，所有的进程第一次创建之后，都进到第一级就绪队列，随着进程的运行，我们可能会降低某些进程的优先级，比如说当一个进程分配给它的时间片用完了，那么它就会降一级，降到第二级就绪队列。 如果它经常地用完时间片，慢慢这个进程就会降低到最后一级就绪队列，进程调度首先在第一级队列里选 那就说明第一级就绪队列的优先级比较高，如果这个队列是空的，调度就会从其他的就绪队列里头选择进程，如果你的进程已经进到了最后一级队列，那么它的优先级就越来越低 它被调度上 CPU 的机会就会变得很小  

![_config.yml]({{ site.baseurl }}/images/88OS/image159.png)  

占用 CPU 的方式：   

抢占则CPU上运行的永远是优先级最高的进程。 

不抢占则正在运行的进程可能比某个在就绪队列中的进程的优先级略微低一点，因为那个进程是在这个进程上CPU之后才进入就绪队列的

![_config.yml]({{ site.baseurl }}/images/88OS/image160.png)  

可以看到 I/O型的进程占用CPU的时间都比较小，在设计调度算法的时候，通常对 I/O 型的进程会比较友好，希望更多的 I/O 型进程早一点上 CPU 运行，因为这些进程上CPU 之后，只用了很短的一下 CPU 时间就会让出 CPU，因为它要去做其它的输入输出操作了。因此对于一般的这个调度程序，都会对 I/O 型进程更偏好一些

![_config.yml]({{ site.baseurl }}/images/88OS/image161.png) 

时间片指的是一个时间段分配给上CPU的进程，允许这个进程在 CPU 上执行多长时间，它是一个时间的长度，选择时间片考虑的因素有，比如说 进程切换它的开销有多大，进程对响应时间的一个要求，系统当中有多少进程处于就绪 CPU 的能力有多大，以及进程的行为，不同进程我可能区别对待。 因此 在设计时间片大小的时候要考虑到这些因素。到底时间片长一点好，还是短一点好？ 每个进程分配的时间片都是固定的，还是可以变化的？  

![_config.yml]({{ site.baseurl }}/images/88OS/image162.png) 


# 3、 

# 4、 

# 5、 

# 6、 

  