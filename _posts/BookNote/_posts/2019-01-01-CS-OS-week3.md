---
layout: post
title: week1 进程线程模型
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、进程的基本概念   

![_config.yml]({{ site.baseurl }}/images/88OS/image91.png)   

从多道程序设计技术这个概念入手进程的基本概念，多道程序设计技术是操作系统最早引入的软件技术

![_config.yml]({{ site.baseurl }}/images/88OS/image92.png)   

第一张图内存里头有四个程序，因为我们只有一个物理的程序计数器，这四个程序是串形执行的，A 程序执行完了， B 程序才能执行   

有了多道程序设计技术之后就得到了这样一个场景，每个程序变换成了一个独立的控制流，占用一个逻辑的程序计数器，这也是操作系统虚拟性的一个体现，把一个物理的程序计数器变换成多个逻辑的程序计数器，实际上每个程序都有自己的程序计数器，那么由于物理上只有一个程序计数器，所以每个程序真正的上CPU，要把逻辑程序计数器的内容推送到物理程序计数器里头，那么通过这种变换达到了在内存中同时有多个程序，达到能够并发执行的效果    

第三张图表示出在一个时间间隔内，每一个程序 A B C D 都执行过了，由于只有一个物理 CPU 所以这些程序是轮流在 CPU 上执行，但是呢从宏观上讲它们都在并发执行。应如何管理在并发环境下同时执行的这些程序？  

![_config.yml]({{ site.baseurl }}/images/88OS/image93.png)   

来看几个并发程序的例子，A和B并发，或B和A并发，前两个例子当中，实际上它们都有一些交错的、 重叠的部分。后面两个例子到A执行完了B才执行 或B执行完了A才执行，由于这两个程序的执行顺序是不可预测的 所以这两种情况都可能在系统中发生。如何刻画在一个并发环境下执行的并发程序？  

![_config.yml]({{ site.baseurl }}/images/88OS/image94.png)  

进程是程序的一次执行过程，一个程序执行了两次，执行了三次，那就是不同的进程。  

进程是运行程序的一个抽象 它代表了所运行的那个环境，也就是它代表了一个 CPU ，因此有时候说进程是对 CPU 的一个抽象 正是因为有了虚拟化技术，所以将一个 CPU 把它变换成多个虚拟的 CPU，每个进程好像都在自己的 CPU 上跑，这就是一个抽象的结果。作为进程，它在运行过程中需要各种各样的资源，所以操作系统的资源是以进程为单位来分配的，比如说内存、文件等等。 最重要的一个资源是地址空间，操作系统为每一个进程分配了一个独立的地址空间。  



操作系统把CPU的控制权交给了某一个进程，让这个进程去运行，那么这就称之为一个调度。所以操作系统通过调度把 CPU 的控制权交给某个进程    

可以通过 Windows 下任务管理器，或者是在 linux 下用 PS 命令，我们就大概知道系统中有多少个进程在运行    

![_config.yml]({{ site.baseurl }}/images/88OS/image95.png)   

操作系统执行过程中会有很多的程序向操作系统提出运行申请，操作系统怎么知道这些进程的存在？所以操作系统为了管理进程设计了一个非常重要的数据结构进程控制块PCB ，这个数据结构实际上是专门用于控制和管理进程的，保存控制和管理进程所需要的所有的信息  

有一个进程存在，就有一个PCB     

操作系统管理了很多的进程，为了便于管理就把所有进程的每个进程的 PCB ，把它集中在一起，放在了内存的固定区域，那么这就是形成了进程表     

进程表大小往往是固定的 ，在一个操作系统中，最多支持多少个进程(最多有多少个进程可以执行)，这叫操作系统的并发度     

**PCB 都应该包含什么内容**  

![_config.yml]({{ site.baseurl }}/images/88OS/image96.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image97.png)   

用户标识符：谁创建这个进程的用户的信息记录

进程组关系：如果这个进程有子进程，有父进程，或兄弟姐妹进程可以把他们的进程的之间的关系记录下来   

![_config.yml]({{ site.baseurl }}/images/88OS/image98.png)   

进程为了调度它的优先级是多少   

![_config.yml]({{ site.baseurl }}/images/88OS/image99.png) 

进程在使用过程中会用到存储空间，会用到一些打开的文件，这些信息要记录在资源和使用里。   

![_config.yml]({{ site.baseurl }}/images/88OS/image100.png)   

 CPU的现场信息是指当进程不运行的时候 ，操作系统要把一些重要的信息、硬件执行的状态信息保存在这个 PCB 里头，这些信息包括了一些通用寄存器 然后程序计数器、 栈指针、 程序状态字等等，以及跟地址空间相关的一个页表的指针     

![_config.yml]({{ site.baseurl }}/images/88OS/image101.png) 

另外一个角度来看PCB的内容 比如说如果是进程管理，它又用到哪些信息？如果从存储管理 进程控制块里要保存什么信息？从文件管理进程控制块要保存什么信息？    

操作系统当中进程控制块的名字是不一样的，比如说在 Linux 当中，进程控制块的名字呢就是 task_struck 在 Widows 当中，进程控制块呢由几部分组成 EPROCESS、 KPROCESS 和 PEB 
 
![_config.yml]({{ site.baseurl }}/images/88OS/image102.png) 
 
Unix 操作系统进程控制块的名字一般叫 Proc 结构，每一个 Proc 结构代表一个 PCB，把所有的 Proc 结构组织成一个链     

Proc 结构应该保存什么信息？重点介绍三个：可执行文件，通过这样一个记录信息，可以找到这个进程所对应的可执行文件，在磁盘上的位置。进程的地址空间，怎么样把它记录在进程控制块( Proc 结构)当中，,因为进程地址空间放了很多内容，每一项内容都放在一段里头。 所以通过段来把进程地址空间描述，把这些段呢 按照地址大小的顺序，把它建立成一个 AVL 树,便于以后的查找。一个地址空间分成很多的段，每个段放了一些内容，要通过一个 AVL 树去找这些段。进程运行过程中需要用到文件，这里有一张表叫做打开文件表，通过这张表可以把所有打开的文件都能找到   

# 2、进程状态及状态转换   

![_config.yml]({{ site.baseurl }}/images/88OS/image103.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image104.png)   

由于进程自身的进展，或者是一些外界条件的变化 进程的状态呢，会有改变 也就是说，从某一个状态进入到另外一个状态  

在两种情况下程序会从运行态回到就绪态，一个是它运行完了分配给它的时间片，它不能再继续运行，回到就绪态，等待下一个时间片的分配。或者一个高优先级的进程进入了就绪态，它会去抢占正在运行的这个进程，那么被抢占的这个进程它也要回到就绪态。  

进程等待某个事件发生的时，它暂时不能运行而进入等待态，比如说它请求了一个操作系统的服务，现在服务还没有结束，或者是它要用某个资源，这个资源还不能被使用，或者是它等待一个I/O的结果，也可能是等待另外一个进程给它发来消息，总之它等不到这个事件，这个进程就不能执行，那么一旦事件发生了，那么它从等待态进入就绪。  

![_config.yml]({{ site.baseurl }}/images/88OS/image105.png)  

操作系统可能还有其它的一些状态    

创建态：已经完成了创建一个进程的必要的工作，分配了PID，填写了PCB。但是由于某种原因，这个进程还不能够马上执行，操作系统没有许可它执行。那么原因可能是由于现在系统资源有限，现在系统负载太大，程序暂时不要运行。  

终止态就是程序结束了，进程结束了它进入了终止态，在进入终止态之后，操作系统还要为这个进程做一些工作，如做一些数据统计工作你用了多少CPU，你用了多少资源，对此做一些记录。另外最重要的是要把你所申请的，所拿到的资源要收回来，因为这个进程已经不再运行了，所以它的所有资源要收回   

挂起态往往指的是在操作系统当中，如果想进行一些负载调节，那可能会把一些进程送入这个状态。系统中进程太多CPU也忙不过来了，所以操作系统会让一部分进程暂时不能运行，但是它又不是等待(不是等待某个事件发生),所以就把它弄成一个特殊的状态，叫挂起态。一旦进程进入了挂起态，操作系统会把它的内存空间收回来，把它的进程的相关的内容送到磁盘上保存起来，那么一旦继续让它运行，这个进程的内容再从磁盘上读入内存，通常称之为激活  

![_config.yml]({{ site.baseurl }}/images/88OS/image106.png)  

运行过程中可能因为超时了等因素从运行回到了就绪，如果运行的进程等待某个事件发生，那么就它变成了等待态，当等待的事件发生了，它就又回到了就绪态。如果进程运行过程中结束了，那么就进入了终止态      

![_config.yml]({{ site.baseurl }}/images/88OS/image107.png)  

操作系统会让一部分就绪的进程进入就绪挂起，然后在某个时候再把它激活。操作系统还会把一些处于阻塞态的进程变成阻塞挂起，进一步减轻系统的负载。 如果条件允许再次激活它，可能在激活之前，等待的事件发生了，那么阻塞挂起的这个进程可以直接进入就绪挂起。当然有的时候也可能会出现让一个正在运行的进程，当它正好下CPU的时候，把它直接送入到就绪挂起的队列   

![_config.yml]({{ site.baseurl }}/images/88OS/image108.png)   

浅度睡眠在睡眠过程中会接收信号，这是一种特定的通信机制 而深度睡眠的进程是不接收信号。然后正在运行的进程呢，可能因为调试，设定了断点，所以它处于了一个叫作暂停状态，这也是跟调试有关系    

![_config.yml]({{ site.baseurl }}/images/88OS/image109.png)   

在实际系统中，就绪态的进程可以排多个不同的队列。等待态有不同的原因，根据等的事件不同，等在不同的队列里头   

有一个就绪队列，创建好的进程通过许可进入就绪队列，被调度程序选中上CPU，运行完了以后退出，如果运行的时间片到了，超时了，它就继续回到就绪队列。运行过程中如果等待某个事件，就进入到相应的等待事件的队列。当这个事件发生就又回到了就绪队列，所以这是一个五状态进程模型当中的一个队列的模型    

# 3、进程控制   

![_config.yml]({{ site.baseurl }}/images/88OS/image110.png) 

进程控制操作主要是完成了进程各状态之间的转换 。进程控制操作实际上就是具有特定功能的程序，那么这个程序执行的时候，由于不允许被中断，所以我们把它称之为原语   

原语又称之为原子操作，它是完成某种特定功能的**一段程序**, 比如说，完成创建，完成阻塞，它是一段程序完成了某种特定功能，但是这个程序在执行过程中是具有不可分割性或是不可中断的,它必须持续地执行,不允许被打断。实现原语需要操作系统通过屏蔽中断一些措施来达到这样一个结果    


![_config.yml]({{ site.baseurl }}/images/88OS/image111.png)    

地址空间，如果在虚拟存储机制之下 那么这个空间呢，就假设给了它，但是不真正，啊，给它内存，只是给了一个虚拟地址空间

在不同的操作系统当中提供了不同的进程创建操作，比如说 UNIX 里头呢，进程创建的主要操作是 fork 和 exec 的一个配合使用，在 WINDOWS 当中是 CreateProcess

![_config.yml]({{ site.baseurl }}/images/88OS/image112.png)    
 
![_config.yml]({{ site.baseurl }}/images/88OS/image113.png)    

![_config.yml]({{ site.baseurl }}/images/88OS/image114.png)    

父进程:   

指已创建一个或多个子进程的进程。在UNIX里，除了进程0以外的所有进程都是由其他进程使用系统调用fork创建的，这里**调用fork创建新进程的进程即为父进程**，而相对应的为其创建出的进程则为子进程，因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。   

子进程:   

指的是由另一进程（对应称之为父进程）所创建的进程。子进程继承了对应的父进程的大部分属性，如文件描述符。在Unix中，子进程通常为系统调用fork的产物。在此情况下，子进程一开始就是父进程的副本，而在这之后，根据具体需要，子进程可以借助exec调用来链式加载另一程序   

fork实际上是创建新的进程，通过复制调用进程本身来创建的，调用进程称之为父进程，也就是通过复制父进程，来创建子进程    

exec是一个系列的系统调用,它的主要目的是通过用一段新的程序来覆盖原来的地址空间，也就是父进程原来是把自己的所有内容复制给子进程，那么子进程用一些新的程序代码，把父进程拷贝过来的内容，给它覆盖掉,通过这样一个覆盖，实现了进程的执行代码的一个转换   

这是 UNIX 里头，最重要的几个进程控制操作 它们都是以系统调用的形式 作为一个接口，呈现给用户程序，由用户程序来调用


![_config.yml]({{ site.baseurl }}/images/88OS/image115.png)    

proc 结构: PCB  
 
以一次一页的方式，把父进程的地址空间内容完全地拷贝给子进程  
 
fork 执行完后，父进程就一分为二，变成了两个进程，一个父进程，一个子进程，在父进程里头，得到的返回值是 pid，在子进程里头，得到的返回值是 0 
 
![_config.yml]({{ site.baseurl }}/images/88OS/image116.png) 

父进程创建子进程是让子进程做与父进程所不同的工作,把所有内容拷贝给子进程，实际上子进程也不需要,因此，子进程会接着执行 exec 这样一个函数用新的一段代码来把父进程拷贝过来的这些地址空间给覆盖掉,因此，之前的这种复制工作实际上就是无用功了。Linux 使用了一个技术改善，叫做写时复制技术 Copy-On-Write，这个技术是在存储管理模块当中提供的一个支持，技术用在了 Linux 的 fork 的实现过程中，采用了这个技术之后在 Linux 里的 fork 加快了速度   

原来是要复制父进程的地址空间，现在只需要父进程把地址空间的指针传递给子进程，再把地址空间设置为只读，当子进程要往地址空间里写东西时，操作系统会为子进程单独再开辟一块空间，把相应的内容放进去 这样的话节省了之前复制父进程地址空间的时间，加快了 fork 的实现速度。 
 