---
layout: post
title: week1 操作系统概述
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、操作系统做了什么  

{% highlight c %}
#include<stdio.h>  
int main(int argc, char *argv[])
{
puts("Hello World");
return 0;
}
{% endhighlight %}   

程序执行过程：  

+ 用户告诉操作系统执行helloworld程序(如何告知？通过命令行输入命令或鼠标点击相应的图标)   

+ 操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址(文件格式？windows是PE,Linux是ELF)   

+ 为了执行程序，操作系统：创建一个新的进程，并将helloworld可执行文件格式映射到该进程结构，表示由该进程执行helloworld程序  

+ 操作系统把控制权交给调度程序：(假设调度程序选中helloworld程序) 操作系统：为helloworld程序设置CPU上下文环境，并跳到程序开始处。  

+ 执行helloworld程序第一条指令，发生缺页异常(程序在执行的时候，先要把程序的代码和数据读入内存CPU才能去执行，但是helloworld程序的代码和数据还没有读入内存，所以硬件机制就会捕获出缺页异常，把控制权交给操作系统)    

+ 操作系统：分配一页物理内存，并将代码从磁盘读入内存(根据前面计算出的磁盘块地址把helloworld程序的代码读入内存)，然后继续执行helloworld程序  

(有的时候程序很大 一页内存还不够，因此在这个执行过程中会多次地产生缺页异常 然后去到磁盘读入程序到内存)  

+ helloworld程序执行puts函数(系统调用)，在显示器上写一字符   

+ 操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以操作系统将要写的字符送给该进程  

+ 操作系统：控制设备的进程告诉设备的窗口系统它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换为像素 把像素写入设备的存储映像区   

+ 视频硬件将像素转换成显示器可接收的一组控制/数据信号   

+ 显示器解释信号，激发液晶屏   

+ 屏幕显示"Hello World"  

**上述步骤得出**   

![_config.yml]({{ site.baseurl }}/images/88OS/image1.png)  

在执行的时，需要操作系统来创建进程，因此到操作系统创建进程，进程创建完，从操作系统返回接着执行这个helloworld程序，出现了缺页异常以后呢，控制权又转回了操作系统 操作系统分配物理内存，给这个用户程序，然后又转向用户程序接着执行，然后helloworld程序又要去执行puts函数，又转向了操作系统    

**换个角度看用户程序执行**   

![_config.yml]({{ site.baseurl }}/images/88OS/image2.png)  

操作系统在执行过程中，如果选中了一个程序，会通过调度选中这个程序，执行这个程序，程序执行过程中，会不断地去陷入操作系统，由操作系统完成一些服务，然后再通过调度再选中程序，接着执行

一个程序的 执行过程中，操作系统负责了这个程序的启动过程 负责了这个程序执行的过程，同时在执行的过程中，不断地去为用户程序的执行 提供各种各样的支持  

# 2、操作系统的定义和作用    

操作系统是计算机系统中的一个系统软件，是一些程序模块的集合， 这些程序模块相互协作、相互配合来完成以下这些功能：  

+ 它们能以尽量有效、合理的方式组织和管理计算机的各种软硬件资源   

+ 为了支持程序的执行，操作系统要合理地组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能。  

+ 操作系统必须采用各种各样的方式使得用户能够非常灵活、方便地使用计算机，采用各种各样的技术使整个的计算机系统能够高效率地运行    

**解读关键词**  

有效：系统效率。资源利用率(CPU利用率充足与否？I/O设备是否忙碌？希望通过操作系统能够把各种各样的资源的利用率提高 以提高整个的操作系统)  

合理： 各种软硬件资源的管理是否公平合理(如果不公平、不合理，则可能会产生问题?)      

方便使用： 用户界面和编程接口(希望能够非常容易地使用操作系统提供给我们的各种接口。 用户界面也就是通过命令行，用户和操作系统打交道,编程接口也就是程序员通过开发软件，在软件中与操作系统打交道 )  

**操作系统的三个作用**   

**1、资源的管理者(有效)**  

从操作系统内部的角度来看操作系统是资源的管理者  

![_config.yml]({{ site.baseurl }}/images/88OS/image3.png)    

![_config.yml]({{ site.baseurl }}/images/88OS/image4.png)    

数据结构是用于记录资源的使用情况，有了数据结构之后还需要算法，也就是说操作系统要确定资源分配策略，操作系统要决定把资源分给哪一个进程用，给它用多久，给它用多少   

静态分配策略就是说一个程序在执行前把它所需的各种资源拿到手，那么这个程序在执行过程中就不再需要新的资源，就可以一直执行完成。静态分配策略会导致整个资源的浪费，有的时候不需要用资源的时候，它拿着资源，别的进程不能用。    

绝大多数操作系统都采用的是一个动态分配策略 那么动态分配策略就是说在一个进程执行的过程中，需要资源时才提出申请。      

例子：页式的存储管理系统，把物理内存划分出很多的物理页面，可以用一个非常简单的数据结构位示图，或者位图 bitmap 来记录这个物理内存的使用情况，一位对应了物理内存的一页，如果这一页是空闲的，那么我们这里头就记为0，如果这一位是分出去了，那我们就记为1,分配算法就实际上就是在这个数据结构上执行。    

分配的过程实际上就是按照策略，按照制定的这种资源分配策略选中要给分配资源的这个进程，然后去决定分配给它多少，然后去修改相应的数据结构。如：如果我们把一内存分配给了一个进程，那么这个位示图就会把这个原来的0改成1，当一个进程使用完资源之后，系统要把它回收 修改相应的数据结构，把原来的1换成0，这就是实施资源分配的和回收的过程   

采用各种各样的技术来提高资源的利用率   

保护资源：使一个进程使用资源的过程不被另外一个进程所干扰 如果在一个系统中有多个进程都对资源有申请，那么产生了冲突的情况下，需要操作系统来协调  

操作系统的五大基本功能：  

![_config.yml]({{ site.baseurl }}/images/88OS/image5.png)   

**2、向用户提供各种服务(方便使用)**  

![_config.yml]({{ site.baseurl }}/images/88OS/image6.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image7.png) 

操作系统完成各种各样的功能，在操作系统之上是应用程序，操作系统为应用程序的执行提供了各种各样的接口，用户的接口和编程的接口，这些就组成了一个虚拟机器界面。 操作系统之下是硬件，操作系统屏蔽了一些硬件的细节，用户程序不需要直接和硬件打交道，通常它都是通过操作系统来控制这些硬件的执行   

那么为什么要用操作系统把硬件屏蔽？因为与硬件相关的一些工作是非常复杂和繁琐的。    

![_config.yml]({{ site.baseurl }}/images/88OS/image8.png) 

**3、对硬件机器的扩展(扩展能力)**   

操作系统就,在应用程序与硬件之间 建立了这么一个等价的一个扩展机器(虚拟机(，那么通过对硬件的抽象提高了整个系统的可移植性,对于程序员提供了这样一个操作系统之后，编程就会比对底层硬件编程更容易

![_config.yml]({{ site.baseurl }}/images/88OS/image9.png) 

**操作系统的三个作用**  

+ 有效地管理资源  

+ 通过命令接口，编程接口等为用户提供各种功能服务  

+ 对硬件机器扩展  

# 3、操作系统的主要特征   

并发、共享、虚拟、随机    

![_config.yml]({{ site.baseurl }}/images/88OS/image10.png) 

操作系统来回管理多个活动，活动和活动之间要有切换    

很多的程序都在内存，需要对内存进行保护，使活动之间互不干扰     

有些问题需要活动相互配合解决，这些相互依赖的活动之间需要解决它的同步等问题   

在宏观上，这些程序好像都在执行着，但是在微观上呢，由于只有一个 CPU，所以任何时刻只有一个程序真正在 CPU 上执行，那可以说这些程序是在 CPU 上是轮流执行，轮流过程需要操作系统提供相应的支持  

并行，多指的是不同的程序同时在多个硬件部件上执行 也就是它会有硬件的多个部件的支持。  

![_config.yml]({{ site.baseurl }}/images/88OS/image11.png) 

互斥共享，比如说像打印机，打印机给一个进程用就不能同时给另外一个进程用。一个进程用完了可以分给另外一个进程用。  

同时共享，两个或两个以上的进程，共享一段代码。不同的文件都放在磁盘上，这个磁盘是共享   

共享就会给操作系统带来管理上的复杂性，操作系统要考虑如何来保护资源 使得不同的进程之间不会互相干扰    

![_config.yml]({{ site.baseurl }}/images/88OS/image12.png)   

假定只有一个物理CPU，宏观上在单CPU上跑了很多的进程，每个进程实际是在虚拟 CPU 上在跑。微观上，每次只有一个进程在一个 CPU 上去跑。 

对于存储器，操作系统给每个进程分配了一个地址空间 这地址空间是一个虚拟地址空间，各个进程之间在相互独立的空间，空间里里放了进程的代码、数据、堆、栈等等，每个进程都有自己的地址空间，那这是逻辑的。 在物理上它会共用一块物理内存。

在显示设备上我们可以开多个窗口或者是虚拟终端，一个显示设备可以显示在不同窗口或者虚拟终端显示不同的内容  

![_config.yml]({{ site.baseurl }}/images/88OS/image13.png)    

多个进程在并发执行，我们看到就是 "走走停停"，一会在 CPU 上执行，一会儿停，一会执行，用户也无法预知每个进程的运行推
 
# 4、典型操作系统的架构    

**Windows**

![_config.yml]({{ site.baseurl }}/images/88OS/image14.png)    

HAL:与计算机打硬件交道  

Kernel: 内核模块主要是处理不同的体系结构之间的相关的一些重要的功能，比如说线程的管理(线程的调度), 还有异常的处理、同路等。  

Device and file system drivers: 设备驱动程序这个模块是完成一些和设备打交道的程序，各种各样的硬件设备驱动程序，还有文件 系统驱动程序，过滤器驱动程序等等   

右下角紫色是图形与窗口系统   

中间呢一大块叫做执行体，执行体提供了各种各样的功能，进程线程管理，虚存的管理器，安全监测器，I/O 管理器和一些对象管理器等等，它还提供了一组函数供用户态程序去调用执行的，这组函数通过了 NTDLL.DLL 这一层提供给用户程序使用   

User mode可以看到有一些系统支持进程，还有一些服务进程，以及大部分的应用程序。 其中里面有一个子系统Win32，环境子系统中比较典型的就是 win32的环境子系统，那么win32的环境子系统呢，实际上是把一些内核的一些系统调用，一些函数经封装成一些特定的形式，提供给用户去使用，编程的时候使用.   

![_config.yml]({{ site.baseurl }}/images/88OS/image15.png)     

动态链接库提供了各种各样的函数给上面执行   

和硬件相关的模块，一个是硬件抽象层，一个是内核(Kernel),不同的体系结构呢是在内核中区别的，那么相同体系结构的不同的计算机在 HAL 层区别的。基本上把所有的硬件的相关处理都封装在这两层里头。 

执行体、图形窗口系统这些模块不和硬件打交道。 那么执行体对外提供了各种各样的函数支持，通过内核态可调用接口、系统服务分发器、动态链接库与对象相接，然后为对象提供各种各样的服务。  

![_config.yml]({{ site.baseurl }}/images/88OS/image16.png)    

操作系统要为用户程序提供各种服务所以有一层系统功能调用层  

**UNIX**   

![_config.yml]({{ site.baseurl }}/images/88OS/image17.png)    

UNIX 操作系统里头是硬件,硬件之上叫操作系统内核。内核外一圈是系统调用接口,系统调用接口之上是 UNIX 各种各样的命令和库。  
  
与Windows相比同样有用户态和内核态，内核态有一个控制进程的子系统，包括了调度、进程间的通信、存储管理，内存管理。 然后有文件系统，各种各样的设备驱动程序，在UNIX里的设备驱动分成块设备的设备驱动和字符设备的设备驱动。 在UNIX里头也有硬件的控制层。 在接近在内核的最上层，可以看到系统调用接口，它是提供给用户程序用的，用户程序可以直接和系统调用接口打交道，也可以通过函数库来和系统调用接口打交道。   

**LINUX**   

![_config.yml]({{ site.baseurl }}/images/88OS/image18.png)    

内核里有进程和调度，有虚存的管理，物理内存的管理，还看到了文件系统，有各种各样的设备驱动程序(字符设备驱动程序，块设备驱动程序，网络的设备驱动程序)。 通常我们操作系统支持网络，有一个网络的模块，按照网络体系结构编写的这个模块，支持网络功能。 还有两个比较重要的模块，一个是陷入和这个异常处理，一个是中断处理，这些都是和硬件相关的,从操作系统角度上对硬件发生的事件的一个处理功能，当然也有系统调用接口   

**ANDROID**  

![_config.yml]({{ site.baseurl }}/images/88OS/image19.png)    


# 5、操作系统的分类     

**操作系统发展历程**   

操作系统发展是随着计算机硬件技术，应用需求的发展、软件新技术的出现而发展的  

目标：充分利用硬件、提供更好的服务  

大型机、个人计算机、网络、移动计算、云计算、泛在计算(物联网)、机器人。随着技术、需求不断发展系统也不断发展。  

**传统操作系统分类**   

批处理操作系统    
分时系统     
实时操作系统    
个人计算机操作系统    
网络操作系统  
分布式操作系统  
嵌入式操作系统   

![_config.yml]({{ site.baseurl }}/images/88OS/image20.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image21.png)  

批处理操作系统中作业呢包括了用户的代码程序，程序需要处理的数据 以及作业执行的规格说明书，其使用一种特定作业控制语言编写的 和现在的脚本很相似，它描述的是作业怎么样去处理的一个步骤

![_config.yml]({{ site.baseurl }}/images/88OS/image22.png) 

卡片读取机,每个程序(代码、数据）都在卡片上   

![_config.yml]({{ site.baseurl }}/images/88OS/image23.png)   

早期的一个解决方案是说增加计算机，这些计算机称为卫星机，它的工作主要是为了完成输入输出。  

![_config.yml]({{ site.baseurl }}/images/88OS/image24.png)  

系统操作员会把在1401(卡片机)上输入的作业放在磁带上，然后把磁带送给7094( 功能非常强大的一台计算机)，7094把作业依次去执行，结果放在磁盘上，然后由操作员去把它送到一个卫星机来做最后的输出工作     

单道批处理：一次处理一个作业，这个作业处理完了 再选择第二个作业进行处理，

多道批处理：一次选多个作业处理    

![_config.yml]({{ site.baseurl }}/images/88OS/image25.png)    

与前面描述的图最大的区别在于，它是在一台机计算机上 完成输入、处理和输出。把所有的工作在一台计算机上执行叫联机操作    

![_config.yml]({{ site.baseurl }}/images/88OS/image26.png)  

这4项任务在同一台计算机上并发的去执行  

当一个作业在主机上执行的时，它不需要到卡片机上去读入数据，只要从输入井上去读数据就可以了。 输出时也不需要把结果直接送到打印机，只要把结果送到输出井，这样提高了整个计算机系统的一个效率

![_config.yml]({{ site.baseurl }}/images/88OS/image27.png)    

多道批处理系统在一台计算机上    

![_config.yml]({{ site.baseurl }}/images/88OS/image28.png)   

打印过程通常采用spooling技术，打印时会把内容放入打印请求队列，其实就是磁盘上的一个目录，操作系统会提供一个打印进程，专门来管理这个打印队列，当这个队列非空时候，进程就被启动啊，把一个一个文件送到打印机上，如果没有打印的请求，这个队列是空打印进程处于等待。

![_config.yml]({{ site.baseurl }}/images/88OS/image29.png) 

一台主机连了多个终端。终端只有键盘、显示器没有计算能力、CPU、存储，所有在终端输入的命令都直接送到主机上，用户输入命令呢，等待回答，然后根据回答的结果再输入命令，一台主机同时要为多个终端去服务。  

![_config.yml]({{ site.baseurl }}/images/88OS/image30.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image31.png) 

![_config.yml]({{ site.baseurl }}/images/88OS/image32.png)  

控制各种各样的实施设备和实施任务协调一致地去工作，如汽车操作，各部件一起响应完成   

![_config.yml]({{ site.baseurl }}/images/88OS/image33.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image34.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image35.png)   

网络操作系统，在网络中有各个计算机，每个计算机都有操作系统，这些操作系统必须支持按网络体系结构协议标准开发的网络模块，网络模块呢主要完成网络的管理，使在网络当中的计算机之间能通信，资源共享以及提供各种各样的网络应用。

![_config.yml]({{ site.baseurl }}/images/88OS/image36.png)  


分布式系统呢，可能是以计算机网络为基础，就是把计算机联网； 也可能是多处理器(CPU)  

通过分布操作系统，允许若干台计算机上完成同一个任务。若操作系统把各种各样的任务分布在系统当中的任何一台计算机上都是可以执行的。     

![_config.yml]({{ site.baseurl }}/images/88OS/image37.png)   


**操作系统的另一种分类(TANENBAUM)**   

大型机操作系统     
服务器操作系统    
多处理机操作系统
个人计算机操作系统  
掌上计算机操作系统   
嵌入式操作系统    
传感器节点操作系统    
实时操作系统     
智能卡操作系统     

![_config.yml]({{ site.baseurl }}/images/88OS/image38.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image39.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image40.png)   


