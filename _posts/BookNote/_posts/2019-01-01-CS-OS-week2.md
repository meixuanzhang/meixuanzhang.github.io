---
layout: post
title: week2 操作系统的运行环境   
date:   2019-03-26
categories: ["Operating Systems"]  
---   

[操作系统原理笔记](https://www.coursera.org/learn/os-pku/home/week/1)  

# 1、处理器状态     

回顾操作系统的主要工作    

+ 程序的执行    
    启动程序、执行程序以及程序结束的工作     

+ 完成与体系结构相关的工作(非常重要的点，这是操作系统与其他软件所不同的地方， 设计操作系统的时候必须和硬件打交道， 必须了解硬件体系结构)   
+ 完成应用程序所需的共性任务    
    提供各种基本服务(在应用程序运行过程中需要做很多的工作。比如说读盘、申请一块内存存放数据、用打印机来打印文件。这些工作是操作系统完成的，并且向用户提供这些基本服务。)   

+ 性能、安全、健壮等问题  	

**本讲主要内容**    

![_config.yml]({{ site.baseurl }}/images/88OS/image41.png)    

## 处理器的状态(模式)   

![_config.yml]({{ site.baseurl }}/images/88OS/image42.png)   

操作系统设计者更加关注的是控制和状态寄存器，其只能由操作系统代码来使用 

![_config.yml]({{ site.baseurl }}/images/88OS/image43.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image44.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image45.png)   

操作系统为多个程序的执行提供了并发环境，多个进程之间共享操作系统所管理的各种资源。并发、 共享的计算环境要求保护用户程序与用户程序之间互不干扰，保护用户程序不对操作系统干扰。   

操作系统与用户能够相隔离。 比如用户程序不能访问操作系统空间，操作系统可以访问用户程序空间
 
在 CPU 上时而运行操作系统、时而运行用户程序，CPU 如何知道运行哪一种状态？这有赖于一些寄存器的某些位的设置，通常是在程序状态字寄存器PSW当中专门设置一位或两位来说明    

不同的程序对资源和指令的使用要求是不同的  

例子中IO PL 是 IO 的权限位，IO 的权限级别。 这个级别可以看到用两位来表示，两位可以表示四个状态。  

![_config.yml]({{ site.baseurl }}/images/88OS/image46.png)   

两个状态可以执行不同的指令集合  

启动I/O，那么各种各样的输入/输出设备由操作系统管理，用户程序如果需要打印、扫描，它自己不能完成这些工作，必须把这个请求提交给操作系统，由操作系统代它来完成这些任务，所以启动 I/O 这个指令是特权指令  
访管指令是非特权指令 但是它的作用是使得用户程序从用户态陷入操作系统内核态

![_config.yml]({{ site.baseurl }}/images/88OS/image47.png)   

硬件设计者设计了不同的特权级别，主要目的是希望在不同的级别能够运行不同的程序。 比如说R0运行操作系统的一些关键代码，所以R0相当于内核态。 R1运行设备驱动程序和一些 I/O 处理的历程，R2 是运行一些受保护的共享的代码，如语言编译环境。而R3是给用户程序使用的。R3相当于用户态， R1和R2实际上是介乎于两者之间，那么不同的这种特权级别其实就是运行指令的集合是不一样   

R0实际上是运行了所有的指令，R3是运行的一个最小的子集  

操作系统需要两个状态，通常情况下大部分的操作系统Linux 、Windows、nix都是只选择了R0和R3这两个特权级别来使用。  

![_config.yml]({{ site.baseurl }}/images/88OS/image48.png) 

有了不同的特权级别，就需要让用户程序和操作系统之间能有转换，用户程序在执行的过程中 如果需要操作系统的服务，它就要从用户态能够进入内核态，用户态进入内核态的一个唯一的途径就是中断/异常/陷入机制    

从内核态返回到用户态呢只是通过设置程序状态字寄存器就可以，设置陷入指令(访管指令)，这条指令的作用是提供给用户程序的一个接口，**用这个接口使用户程序可以向操作系统提出各种服务请求**       
 
为什么叫访管指令？因为有的时候内核态也被称为一个supervisor mode管理态。从用户态进入了管理态，相当于访问管理态，那么这条特殊的指令在不同的计算机系统当中呢 实际上是用不同的指令的。 比如有 int 指令 有 trap 指令，syscall 还有sysenter/sysexit。



# 2、中断与异常机制介绍     

![_config.yml]({{ site.baseurl }}/images/88OS/image49.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image50.png) 

中断与异常的概念实际上是 CPU 对系统发生的某个事件的一种反应，当这个事件发生的时候，对这个事件的处理实际上是改变了一个控制流    

发生了事件之后 CPU 会暂停正在执行的程序保留现场。 然后自动去执行对这个事件的处理程序，完成了这个处理过程之后返回到断点，继续执行刚才被打断的程序。  
 
中断或异常这个事件是随机发生，何处发生？何时发生？事先是不能判断。中断和异常处理是一个自动处理的过程，强调这个过程是由硬件来完成的 硬件自动地完成整个控制流的转移工作。中断和异常事件发生之后是可恢复的，可恢复呢指的是这个事件完了之后被打断的这个程序可以在以后某个时刻再接着执行    

中断的引入 实际上是为了支持 **CPU 与外部设备的一个并行操作**，如果没有中断机制的话,那么 CPU 要负责对设备的所有工作的管理,向 CPU 发中断呢是一种向 CPU 汇报的手段    

早期不区分中断和异常的都叫中断，但是随着它们发生的原因不同，处理的一些过程不同，那么就有了中断和异常这么一个区分   

![_config.yml]({{ site.baseurl }}/images/88OS/image51.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image52.png) 

在键盘上按了 Ctrl + C,网卡接收到一个新的数据包,打印机结束了,读盘结束了,这样一些事件的发生带来的是 I/O 中断   

时钟中断,比如设定了一个定时器到点了,CPU 上运行的程序它的时间片到了，这些我们都称之为时钟中断  

硬件故障中断,比如说笔记本电脑快没电了,它要报警，提示你赶紧存盘或充电。读内存时候,奇偶校验。  

系统调用其实是属于异常的 还有页故障或者叫页错误异常 那么我们在第一讲当中介绍 HelloWorld 程序执行过程中 第一条指令执行的时候产生了一个缺页异常，因为 要执行的代码在磁盘上还没有读入内存，那么这个时候 执行到这里的时候会，硬件会产生一个 叫做页故障，那我们具体的页故障就是缺页异常 保护性异常。 比如说一块内存空间 它呢标记成只读。 当要做一个写的操作 这个就冲突了，操作和它的权限冲突了，所以这时候呢会引发一个保护性异常 如果要访问一个这个内存空间 那么访问的这个区域的地址越界了，那么也算保护性异常 还有就是断点指令，包括了我们说我们要调试程序，我们要设置 单步的调试，那么这样的话呢就要设置这样一个断点指令 你这样的话呢这就是一个异常。 当然还有很多的异常我们称之为程序性 异常。 程序性异常我们都比较常见，比如我们前面说的 算术溢出啊，除零啊，栈溢出等等都属于程序性异常 

![_config.yml]({{ site.baseurl }}/images/88OS/image53.png)  

中断是外部事件在 CPU 之外产生的事件打断了CPU，这些事件是正在运行的程序所不期望的，异常是由正在执行的指令而引发的。    

中断实际上是来自各种各样的外部设备和一些硬件部，它是个异步的事件。

如果在执行指令的时候发生了故障 这个故障又是可恢复的，那么去做处理，最后返回到刚才发生故障的这条指令，返回到当前指令，如果这个故障呢是不可恢复的，那我们把它称之为终止    

# 3、中断与 异常机制 工作原理   

![_config.yml]({{ site.baseurl }}/images/88OS/image54.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image55.png)  

处理器控制部件当中设置了一个中断寄存器保存发来的各种各样的中断信号   

![_config.yml]({{ site.baseurl }}/images/88OS/image56.png)  

查中断向量表是把中断处理程序把它调出来，调出来以后在下一个周期，实际上就是执行中断处理程序，如果没有中断或不接收中断，那么就继续执行下一条指令 
 
中断向量表实际上是个非常重要的软硬件结合的一个数据结构   
  
![_config.yml]({{ site.baseurl }}/images/88OS/image57.png)  
  
中断向量表每一行实际上是一个中断向量，中断向量表是由若干中断向量组成，每一个中断向量其实就是一个内存单元，它是存放了中断处理程序的这个入口地址以及这个程序在运行的时候所需要的一个处理机的状态字，操作系统事先填写中断向量表 事先先编好中断处理程序，把这些中断处理程序的起始地址或者入口地址填在中断向量表里，那么当中断发生的时候，执行流程就会按照中断的号或者是异常的类型不同通过中断向量表把控制权转移给对应的中断处理程序。    

![_config.yml]({{ site.baseurl }}/images/88OS/image58.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image59.png)   


第一步，设备发来了中断信号    

第二步，中断硬件部件保存现场，把这些内容保存到了系统堆栈里头，保存的内容我们也可以看到主要的是 PSW 加 PC 的内容      

第三步， 中断硬件根据中断码来去查中断向量表，通过查中断向量表得到对应的中断处理程序   

第四步，把中断处理程序的入口地址等相关信息推送到相应的寄存器，那么下一个指令周期开始就是执行中断处理程序了，当一个程序正在执行过程中被打断了，被打断那一点叫做中断的断点，然后转去执行相应的中断处理程序，执行完中断处理程序之后，返回到刚才的断点继续执行。   

![_config.yml]({{ site.baseurl }}/images/88OS/image60.png)   

中断处理程序首先要保存相关寄存器的信息，在刚才那张图中硬件部件会保存关键寄存器的信息，那么其他的一些寄存器的信息呢还要再做进一步地保存   

究竟是哪一类中断，哪一类异常？ 比如以打印机为例，打印机来了中断信号，那么具体的原因是打印机正常地完成了任务还是由于没有打印纸了，或者是没有碳粉了来发出的警告，根据这个具体原因执行对应的处理程序

当然如果有些中断发生了严重的错误可能就不再返回了就报错退出了，大部分情况下执行完处理程序之后会恢复现场，返回被事件打断的这个程序。 

总结：软件提前设置好，硬件部件来执行   

![_config.yml]({{ site.baseurl }}/images/88OS/image61.png)    

![_config.yml]({{ site.baseurl }}/images/88OS/image62.png)   

CPU的状态恢复成原来的状态，如果是从用户态进到核心态，那么就把它设置成用户态  

![_config.yml]({{ site.baseurl }}/images/88OS/image63.png)   

如果有程序正在等待这次I/O的结果，那么就把它唤醒，让它继续做要做的工作。 如果有新的I/O操作在等待，要执行新的 I/O操作，那么就要准备好数据，重新启动I/O   

如果在I/O过程中出现了错误 那么，首先需要的是重复执行一下刚才失败的I/O操作，看看是不是偶然发生了错误，但是这个重新执行是有上限的，比如说我重新执行两次或者三次 达到了上限之后，系统呢就会报错了   

# 4、实例：X86的中断与异常机制

![_config.yml]({{ site.baseurl }}/images/88OS/image64.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image65.png) 

在X86处理器中我们有实模式和保护模式之分  

在保护模式下中断向量表改了个名字叫中断描述符表。 那么中断描述符表当中每一个中断向量叫门描述符，这是一个数据结构

![_config.yml]({{ site.baseurl }}/images/88OS/image66.png)   

通常只用了两种门，一个是中断门，一个是陷阱门  

中断门通过之后，系统会自动禁止中断，就不再接收新的中断了  

陷阱门的处理是和中断门相似，只是通过了陷阱门之后不会自动禁止中断，所以还可以接收新的中断    

门描述符的一些具体的数据结构和整个的中断响应过程：  

![_config.yml]({{ site.baseurl }}/images/88OS/image67.png)    

通过IDTR寄存器我可以得到中断描述符表的地址，我可以找到中断描述符表  

中断描述符表的每一行是一个门描述符或者叫做中断描述符   

中断描述符的格式：它是 64 位，分成不同的内容。这有一个门的类型，记录是中断门还是陷阱门。 还有一个是 DPL特权级，描述了特权级别。 通过这个中断描述符我们得到了一个段选择符。段选择符其实就是个索引，GDT或LDT表示在哪个表索引，段选择符还有特权级。有了这个索引之后，我们用它来查表。中断处理程序的相关信息放在表的某一行。 那么查到这张表之后我们就得到了一个段描述符。 

这个段描述符属性里头也有相应的权限，每一个段都有相应的权限，表明它的特权级别     

段描述符主要关注的是段的基地址。 有了段的基地址，有了在中断描述符当中的偏移，我们就得到了中断服务程序的一个入口地址。 

![_config.yml]({{ site.baseurl }}/images/88OS/image68.png)    

(发生特权级变化)从用户态进到了内核态， 原来的堆栈指针指向的是用户态，用户栈， 现在需要把堆栈的指针指向内核栈， 然后才能够做下面的工作。  

如果是中断门进来的，那么就要把 IF 位清掉，禁止后面的中断了。 当然如果是陷阱门进来就不需要做这件事。  
 
![_config.yml]({{ site.baseurl }}/images/88OS/image69.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image70.png)    

# 5、系统调用机制  

系统调用机制是操作系统向用户程序提供的**接口**      

![_config.yml]({{ site.baseurl }}/images/88OS/image71.png)  

系统调用全称是操作系统功能调用   

用户不能直接执行特权指令，所以需要通过了一个接口向操作系统提出请求，由操作系统来完成这个过程。通过这个接口，实现从用户态陷入内核态，这就是操作系统当中系统调用(接口)所起的作用。  

进程控制类比如说创建进程，撤销进程。进程通信类，那么一个进程可以给另外一个进程发消息。文件使用类，比如说创建 撤销、 打开、 关闭、 读、 写文件。   

![_config.yml]({{ site.baseurl }}/images/88OS/image72.png)    

应用程序可以直接调用系统调用(接口)，但是通常情况应用程序都是通过了C函数库或API的接口来间接地调用系统调用(接口)，在操作系统内核当中提供了很多的内核函数，这些内核函数经过了封装，把它提供到了C函数库或API接口，所以**内核函数就是这个系统调用(接口)的处理程序**，这些处理程序通过封装在C函数库或API接口提供给用户来使用   

C函数库里头或API接口里头还有一些函数，它们不是系统调用(接口)，它们就是一些普通的函数，一些函数通过系统调用(接口)对应到了多个内核函数，当然也可能是某一个函数通过系统调用(接口)对应内核的一个函数。内核函数当中也有一些函数是不开放给用户使用的   

![_config.yml]({{ site.baseurl }}/images/88OS/image73.png)  

所有的系统调用(接口)都是通过访管指令来进入内核，在中断向量表或中断描述符表当中有一行专门用于系统调用(接口)，在操作系统初始化的时候，要把这个表的这一项设置好。   

操作系统要事先给每一个系统调用(接口)一个编号(系统调用号、功能号),系统调用(接口)都是通过访管指令进入内核，到底哪一个系统调用(接口)进入内核要通过编号来区分。每个系统调用有不同的参数，有的系统有参数，有的没有参数，所以我们还要设计相应的参数，那么这些工作除了操作系统的设计之外，还需要编译器来帮忙，编译器会把封装的系统调用把它展开，在过程中生成访管指令以及参数推送到寄存器的指令。(参数的推送寄存器?)   

每一个系统调用(接口)都有一段内核函数或是一段代码来对应,那么怎样找到对应的内核函数呢？我们需要设计一张系统调用表,把系统调用的各项服务的入口地址填在这张表里头,这张表也是在初始化的时候设置好了

![_config.yml]({{ site.baseurl }}/images/88OS/image74.png)    

用户程序在执行的时候是用户栈。一般的函数调用是通过用户栈来传递参数的,现在面临的问题是用户和系统,用户程序不能够把它的参数推到系统栈里去,大部分情况下会采用第二种方案解决   

![_config.yml]({{ site.baseurl }}/images/88OS/image75.png)    

把 write 函数对应的系统调用号，推到寄存器里头，要在这里安排一条特殊的陷入指令。  

![_config.yml]({{ site.baseurl }}/images/88OS/image76.png)     
 
write有三个参数：第一个参数是 1 ，表示的是要把结果送到标准输出设备上； 然后送的内容是放在了字符串里头。长度是 7  
 
return 是一个函数也是一个系统调用   

![_config.yml]({{ site.baseurl }}/images/88OS/image77.png)     

(9,10,11,12)把一些数据推送到寄存器里头  

数据包括包括了系统调用的编号，write 这个系统调用编号是 4，把4推送到了eax寄存器，eax 寄存器存放了系统调用的编号。 剩下的 write 的三个参数依次送到不同的寄存器。 然后安排了一条特殊的指令(陷入指令)。 通过这个陷入指令在执行这段代码的时候会引发一次系统调用。   

return 系统调用作用是返回、退出,系统调用编号是 1 ,也安排了一个特殊的陷入指令  

![_config.yml]({{ site.baseurl }}/images/88OS/image78.png)    
 
中断处理程序，因为我们是系统调用所以叫做系统调用的一个总入口程序,所有的系统调用都是通过这个中断向量进来，都是执行这个总的入口程序    

#6、实例：基于X86的Linux系统调用机制简介    

![_config.yml]({{ site.baseurl }}/images/88OS/image79.png)  

通过这个段选择符和这个偏移量 能够最终使得硬件找到 中断处理程序也就是 system_call()  

采用的是陷阱门是因为在执行系统调用过程中，我们还允许接收中断   

特权级设置为 3 ，因为我们知道，在用户态进入到内核态的时候要经过这个门，用户态的特权级是 3那么在经过这个门的时候，要求当前运行程序的这个特权级(为3)要等于或者高于要执行的这个代码段(中断处理程序)的级别。 你要执行的中断处理程序如果它的特权级不是 3，那么那就是 0，这 0比 3 的级别要高，它就进不来了。 所以要保证用户态能进到核心态，所以这个门描述符一定要是是 3，与用户态特权级相同，这样就允许用户可以通过这个门描述符   

![_config.yml]({{ site.baseurl }}/images/88OS/image80.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image81.png)  

![_config.yml]({{ site.baseurl }}/images/88OS/image82.png)  
![_config.yml]({{ site.baseurl }}/images/88OS/image83.png)  
![_config.yml]({{ site.baseurl }}/images/88OS/image84.png)  
![_config.yml]({{ site.baseurl }}/images/88OS/image85.png)  
![_config.yml]({{ site.baseurl }}/images/88OS/image86.png)   


SAVE_ALL 的一段代码： 

![_config.yml]({{ site.baseurl }}/images/88OS/image87.png)   
 
SAVE_ALL 把其他的一些剩余的寄存器内容压栈，压完栈之后，栈的状态布局如图，栈前面的信息是硬件压的，然后系统调用号是system_call()程序推送的，剩下的从ES开始这些是 SAVE_ALL 完成的，完成之后就把这个栈增长了  

![_config.yml]({{ site.baseurl }}/images/88OS/image88.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image89.png)   

![_config.yml]({{ site.baseurl }}/images/88OS/image90.png)  